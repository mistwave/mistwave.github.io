<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yifu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://duanyifu.com/"/>
  <updated>2020-01-31T08:41:06.385Z</updated>
  <id>http://duanyifu.com/</id>
  
  <author>
    <name>Yifu Duan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>客户端删除DOM节点的几种方式</title>
    <link href="http://duanyifu.com/2020/01/31/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%A0%E9%99%A4DOM%E8%8A%82%E7%82%B9%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://duanyifu.com/2020/01/31/客户端删除DOM节点的几种方式/</id>
    <published>2020-01-31T01:31:56.000Z</published>
    <updated>2020-01-31T08:41:06.385Z</updated>
    
    <content type="html"><![CDATA[<p>B站首页有一些板块实在是<strong>辣眼睛</strong>，所以得想办法处理一下。</p><p><img src="https://vip1.loli.net/2020/01/31/kiCKtmYol6Upbyh.jpg" alt="needremovebilibili.jpg"></p><h2 id="准备工作">准备工作</h2><p>我常用的浏览器是Chrome，所以就用<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">Tampermonkey</a>来加载脚本。</p><p>原理也很简单，等页面加载完成后，我们可以用Tampermonkey再跑一段自定义的JavaScript，用来操作DOM树。</p><p>然后通过Chrome的审查元素，得知，需要去除的元素id分别为<code>bili_report_live</code>和<code>reportFirst2</code>。</p><a id="more"></a><h2 id="version-1">Version 1</h2><p>根据我十分浅薄的前端知识，写下了非常<em>naïve</em>的两行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"bili_report_live"</span>).remove();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"reportFirst2"</span>).remove();</span><br></pre></td></tr></table></figure><p>实验发现，在REPL（Console tab in dev tools）里输入这两行是可行的，但是放在Tampermonkey中，就不行了。</p><p>没关系，我们依然可以在REPL中看见报错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &apos;remove&apos; of null</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>NPE了，推测是脚本执行时机的问题，Tampermonkey执行脚本的时候，我们需要的节点还没有生成。</p><h2 id="version-2">Version 2</h2><p>既然如此，我们尝试等待一会儿再执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.getElementById(<span class="string">"bili_report_live"</span>).remove(), <span class="number">500</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.getElementById(<span class="string">"reportFirst2"</span>).remove(), <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>尝试了下500ms的超时，在大多数情况下可以正确处理，但是如果网络波动了，就会失败。</p><p>除此之外，还有点令人不爽，你会看着这两块内容<strong>先出现，再消失</strong>。</p><p>看看还有没有别的办法。</p><h2 id="version-3">Version 3</h2><p>CSS的id selector是个好选择，DOM树中有了就自动应用样式，没有的话也不影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">document</span>.head || <span class="built_in">document</span>.documentElement)</span><br><span class="line">  .insertAdjacentHTML(<span class="string">'beforeend'</span>,</span><br><span class="line">                      <span class="string">'&lt;style&gt;#bili_report_live &#123; display: none!important; &#125;&lt;/style&gt;'</span>);</span><br><span class="line">(<span class="built_in">document</span>.head || <span class="built_in">document</span>.documentElement)</span><br><span class="line">  .insertAdjacentHTML(<span class="string">'beforeend'</span>,</span><br><span class="line">                      <span class="string">'&lt;style&gt;#reportFirst2 &#123; display: none!important; &#125;&lt;/style&gt;'</span>);</span><br></pre></td></tr></table></figure><h2 id="version-4">Version 4</h2><p>这个需求其实有个简单的思路：我希望能在DOM树变更的时候被通知到。</p><p>在MDN搜索了一下，果然有这个API：<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a></p><p>这样写也就OK了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">document</span>.getElementById(<span class="string">"bili_report_live"</span>)</span><br><span class="line">  <span class="keyword">if</span> (e) &#123;</span><br><span class="line">    e.remove();</span><br><span class="line">    <span class="keyword">this</span>.disconnect();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">document</span>.getElementById(<span class="string">"reportFirst2"</span>)</span><br><span class="line">  <span class="keyword">if</span> (e) &#123;</span><br><span class="line">    e.remove();</span><br><span class="line">    <span class="keyword">this</span>.disconnect();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>v3和v4都是不错的方法，能够完美解决这个问题，我的前端知识又前进了一小步。</p><p>现在b站首页看起来就是这个样子了，很清爽，哈哈哈哈哈哈。</p><p><img src="https://vip1.loli.net/2020/01/31/LeX9iZvPyKhVWB5.png" alt="IMG_5192.PNG"></p><p>完整脚本如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         去除bilibili推广栏和直播栏</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.2</span></span><br><span class="line"><span class="comment">// @description  try to take over the world!</span></span><br><span class="line"><span class="comment">// @author       You</span></span><br><span class="line"><span class="comment">// @match        https://www.bilibili.com/</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here...=</span></span><br><span class="line">    <span class="comment">// v3</span></span><br><span class="line">    <span class="comment">// (document.head || document.documentElement)</span></span><br><span class="line">    <span class="comment">//   .insertAdjacentHTML('beforeend',</span></span><br><span class="line">    <span class="comment">//                       '&lt;style&gt;#bili_report_live &#123; display: none!important; &#125;&lt;/style&gt;');</span></span><br><span class="line">    <span class="comment">// (document.head || document.documentElement)</span></span><br><span class="line">    <span class="comment">//   .insertAdjacentHTML('beforeend',</span></span><br><span class="line">    <span class="comment">//                       '&lt;style&gt;#reportFirst2 &#123; display: none!important; &#125;&lt;/style&gt;');</span></span><br><span class="line">    <span class="comment">// v4</span></span><br><span class="line">    <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> e = <span class="built_in">document</span>.getElementById(<span class="string">"bili_report_live"</span>)</span><br><span class="line">        <span class="keyword">if</span> (e) &#123;</span><br><span class="line">            e.remove();</span><br><span class="line">            <span class="keyword">this</span>.disconnect(); <span class="comment">// disconnect the observer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span>(<span class="params">mutations</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> e = <span class="built_in">document</span>.getElementById(<span class="string">"reportFirst2"</span>)</span><br><span class="line">        <span class="keyword">if</span> (e) &#123;</span><br><span class="line">            e.remove();</span><br><span class="line">            <span class="keyword">this</span>.disconnect(); <span class="comment">// disconnect the observer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).observe(<span class="built_in">document</span>, &#123;<span class="attr">childList</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;B站首页有一些板块实在是&lt;strong&gt;辣眼睛&lt;/strong&gt;，所以得想办法处理一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://vip1.loli.net/2020/01/31/kiCKtmYol6Upbyh.jpg&quot; alt=&quot;needremovebilibili.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;我常用的浏览器是Chrome，所以就用&lt;a href=&quot;https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tampermonkey&lt;/a&gt;来加载脚本。&lt;/p&gt;
&lt;p&gt;原理也很简单，等页面加载完成后，我们可以用Tampermonkey再跑一段自定义的JavaScript，用来操作DOM树。&lt;/p&gt;
&lt;p&gt;然后通过Chrome的审查元素，得知，需要去除的元素id分别为&lt;code&gt;bili_report_live&lt;/code&gt;和&lt;code&gt;reportFirst2&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Javascript" scheme="http://duanyifu.com/tags/Javascript/"/>
    
      <category term="Frontend" scheme="http://duanyifu.com/tags/Frontend/"/>
    
      <category term="Tampermonkey" scheme="http://duanyifu.com/tags/Tampermonkey/"/>
    
  </entry>
  
  <entry>
    <title>ForkJoinPool简介</title>
    <link href="http://duanyifu.com/2019/12/30/ForkJoinPool/"/>
    <id>http://duanyifu.com/2019/12/30/ForkJoinPool/</id>
    <published>2019-12-29T22:33:56.000Z</published>
    <updated>2019-12-31T05:24:30.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tl-dr">TL;DR</h2><p><code>ForkJoinPool</code>是实现了<a href="https://en.wikipedia.org/wiki/Work_stealing" target="_blank" rel="noopener">work stealing</a>的线程池，其中所有线程都是<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" target="_blank" rel="noopener">daemon thread</a>。</p><h2 id="几个栗子🌰">几个栗子🌰</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7+</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="number">10</span>)</span><br><span class="line">  .thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; <span class="number">32</span>),</span><br><span class="line">                    Integer::sum)</span><br><span class="line">  .thenAcceptAsync(x -&gt; System.out.println(<span class="string">"The answer is "</span> + x + <span class="string">"!"</span>));</span><br><span class="line"><span class="comment">// The answer is 42!</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8+</span></span><br><span class="line">LongStream.rangeClosed(<span class="number">1</span>, <span class="number">1000000</span>)</span><br><span class="line">  .parallel()</span><br><span class="line">  .sum()</span><br><span class="line"><span class="comment">// 500000500000</span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scala</span></span><br><span class="line">(<span class="number">1</span> to <span class="number">1000000</span>).toVector.par.fold(<span class="number">0</span>)(_ + _)</span><br><span class="line"><span class="comment">// 500000500000</span></span><br></pre></td></tr></table></figure><p>三个例子分别是：</p><ol><li>使用<code>CompletableFuture</code>组合异步计算：其中每个以<em>Async</em>结尾的方法，都再次将任务提交给了线程池，大概率会在另外一个线程中执行；</li><li>使用<code>.parallel()</code>并行处理Stream：<code>.sum()</code>对并行Stream有优化，可以提升效率；</li><li>使用<code>.par</code>将<code>Vector</code>变成并行的进行<code>fold</code>：Monoid满足结合律，所以可以并行<code>fold</code>。</li></ol><p>承载这些异步、并行计算的线程池，默认会使用一个JVM为我们生成的<code>ForkJoinPool</code>，可以用<code>ForkJoinPool.commonPool()</code>得到实例。</p><p>除此之外，Scala中的<code>scala.concurrent.Future</code>一般会使用到<code>scala.concurrent.ExecutionContext.Implicits.global</code>，而后者就是包装了这个common pool。</p><a id="more"></a><h2 id="forkjoinpool是个线程池？">ForkJoinPool是个线程池？</h2><p>没错，<code>ForkJoinPool</code>实现了<code>ExecutorService</code>接口，是个线程池。</p><p>对于common pool，我们可以看见它的默认大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CPU: i7-7920HQ(4 Cores, 8 Threads @3.10 GHz): </span></span><br><span class="line">System.out.println(ForkJoinPool.getCommonPoolParallelism());</span><br><span class="line"><span class="comment">// 7, the rest one is for main thread</span></span><br><span class="line"></span><br><span class="line">System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>相比其他线程池，<code>ForkJoinPool</code>有两个显著的特点：</p><ol><li>所有线程都是daemon thread，这意味着当JVM停止时，所有未完成的任务会直接终中断；</li><li>work stealing策略：每个线程会有自己的deque来维护任务列表，当自己的deque空了，会从别的thread队列（或者是pool级别的deque）末尾偷任务过来执行。换句话说，每个线程都会<strong>尽可能地不让自己空闲下来</strong>。</li></ol><h2 id="比较好的实践">比较好的实践</h2><ol><li>不要提交<strong>可能阻塞</strong>的任务，这样可能阻塞所有线程，使整个线程池无法响应；</li><li>如果一定要这么做（<code>ForkJoinPool</code>会先增大并发度（加线程），再处理）：<ul><li>Java用<code>managedBlock(ForkJoinPool.ManagedBlocker blocker)</code>来替代<code>submit</code>、<code>execute</code>等</li><li>Scala的<code>Future</code>使用<code>scala.concurrent.blocking</code></li></ul></li><li>如果要sync，使用<code>CompletableFuture</code>的<code>join()</code>或者<code>CountDownLatch</code>。</li></ol><h2 id="另一种用法">另一种用法</h2><p>上面描述的用法，主要在利用了work stealing以及common pool。</p><p>仔细浏览一下<code>ForkJoinPool</code>的API，会发现有一个长得很像的类<code>ForkJoinTask</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure><p><code>ForkJoinTask</code>有这么几个特点：</p><ol><li>可以对分治递归进行建模，拆分出来的子任务让线程池去处理；</li><li>子任务可以依赖父任务，任务间依赖构成DAG；</li><li>可以当成<code>Future</code>使用。</li></ol><p>具体实践的例子可以参考这里<a href="https://www.baeldung.com/java-fork-join" target="_blank" rel="noopener">Guide to the Fork/Join Framework in Java</a>。</p><p>不过这种并发模型挺诡异的，可维护性也比较差。如果能够使用别的模型，还是尽量不要用这个。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tl-dr&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ForkJoinPool&lt;/code&gt;是实现了&lt;a href=&quot;https://en.wikipedia.org/wiki/Work_stealing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;work stealing&lt;/a&gt;的线程池，其中所有线程都是&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daemon thread&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;几个栗子🌰&quot;&gt;几个栗子🌰&lt;/h2&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Java 7+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CompletableFuture.supplyAsync(() -&amp;gt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .thenCombineAsync(CompletableFuture.supplyAsync(() -&amp;gt; &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Integer::sum)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .thenAcceptAsync(x -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;The answer is &quot;&lt;/span&gt; + x + &lt;span class=&quot;string&quot;&gt;&quot;!&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// The answer is 42!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Java 8+&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LongStream.rangeClosed(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1000000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .parallel()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .sum()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 500000500000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Scala&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to &lt;span class=&quot;number&quot;&gt;1000000&lt;/span&gt;).toVector.par.fold(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)(_ + _)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 500000500000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;三个例子分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;CompletableFuture&lt;/code&gt;组合异步计算：其中每个以&lt;em&gt;Async&lt;/em&gt;结尾的方法，都再次将任务提交给了线程池，大概率会在另外一个线程中执行；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;.parallel()&lt;/code&gt;并行处理Stream：&lt;code&gt;.sum()&lt;/code&gt;对并行Stream有优化，可以提升效率；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;.par&lt;/code&gt;将&lt;code&gt;Vector&lt;/code&gt;变成并行的进行&lt;code&gt;fold&lt;/code&gt;：Monoid满足结合律，所以可以并行&lt;code&gt;fold&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;承载这些异步、并行计算的线程池，默认会使用一个JVM为我们生成的&lt;code&gt;ForkJoinPool&lt;/code&gt;，可以用&lt;code&gt;ForkJoinPool.commonPool()&lt;/code&gt;得到实例。&lt;/p&gt;
&lt;p&gt;除此之外，Scala中的&lt;code&gt;scala.concurrent.Future&lt;/code&gt;一般会使用到&lt;code&gt;scala.concurrent.ExecutionContext.Implicits.global&lt;/code&gt;，而后者就是包装了这个common pool。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Java" scheme="http://duanyifu.com/tags/Java/"/>
    
      <category term="Scala" scheme="http://duanyifu.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Monad in FP, Part I</title>
    <link href="http://duanyifu.com/2019/10/31/monad-in-FP-part-I/"/>
    <id>http://duanyifu.com/2019/10/31/monad-in-FP-part-I/</id>
    <published>2019-10-31T10:22:56.000Z</published>
    <updated>2019-10-31T10:20:58.301Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Monad ---- “the m-word”，“a monoid in the category of endofunctors”.</em></strong><br><em>see <a href="https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem" target="_blank" rel="noopener">A monad is just a monoid in the category of endofunctors, what’s the problem?</a> for fun</em></p><hr><p>在FP的路上，不可避免地会碰到monad这个拦路虎。绕是绕不过去的，那就学咯。</p><p><em>“我看了几十篇关于monad的文章，还是没懂。” – 某不知名FP爱好者</em></p><p>这篇文章也不是silver bullet，我只希望读者在读过以后，对monad能有个大致的、模糊的印象，今后能够持续地从多个角度去审视这个概念，加深认识。</p><h2 id="什么是monad">什么是monad</h2><p>我们在说functor的时候，有一个不那么准确的定义：<strong>有<code>map</code>的，就是functor</strong>。</p><p>当我们这样定义的时候，我们其实是在泛化<code>map</code>，将它们的共性抽象出来，这个抽象就是functor。</p><p>同样地，<code>flatMap</code>也出现在很多地方（比如<code>List</code>，<code>Option</code>，<code>Future</code>，<code>Either</code>等等等），我们自然也想把共性抽象出来，这个抽象，就是monad。所以可以类似地说：<strong>有<code>flatMap</code>的，就是monad</strong>。</p><p>好吧，如果要正式一点，引用下<em>scala with cats</em>里的定义：<strong>monad是一种将计算按顺序排列起来的机制（a mechanism for sequencing computations）</strong>。</p><a id="more"></a><h2 id="flatmap是什么"><code>flatMap</code>是什么</h2><p>如果你熟悉<code>flatMap</code>，可以跳过这一小节。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, friends: <span class="type">List</span>[<span class="type">String</span>]</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">bob</span> </span>= <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="type">List</span>(<span class="string">"Alice"</span>, <span class="string">"Pika"</span>))</span><br><span class="line"><span class="comment">// bob: Person = Person("Bob", List("Alice", "Pika"))</span></span><br><span class="line"><span class="keyword">val</span> harry = <span class="type">Person</span>(<span class="string">"Harry"</span>, <span class="type">List</span>(<span class="string">"Ron"</span>, <span class="string">"Hermione"</span>))</span><br><span class="line"><span class="comment">// harry: Person = Person("Harry", List("Ron", "Hermione"))</span></span><br><span class="line"><span class="keyword">val</span> ps = <span class="type">List</span>(bob, harry)</span><br><span class="line"><span class="comment">// ps: List[Person] = List(Person("Bob", List("Alice", "Pika")), Person("Harry", List("Ron", "Hermione")))</span></span><br><span class="line"></span><br><span class="line">ps.map(_.friends)</span><br><span class="line"><span class="comment">// res4: List[List[String]] = List(List("Alice", "Pika"), List("Ron", "Hermione"))</span></span><br><span class="line"></span><br><span class="line">ps.flatMap(_.friends)</span><br><span class="line"><span class="comment">// res5: List[String] = List("Alice", "Pika", "Ron", "Hermione")</span></span><br></pre></td></tr></table></figure><p>对于<code>List[A]</code>来说，<code>map</code>和<code>flatMap</code>的签名，仅仅是传入的<code>f</code>的返回类型不一样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">List</span>[<span class="type">B</span>]): <span class="type">List</span>[<span class="type">B</span>]</span><br></pre></td></tr></table></figure><p>直观来讲，<code>flatMap</code>将<code>List</code>内的每一个A，转换成了一个<code>List[B]</code>，然后将所有的<code>List[B]</code>，连了起来。</p><h2 id="举个栗子🌰">举个栗子🌰</h2><p>我们知道，<code>Option</code>可以用来表示结果是否存在。</p><p>考虑整数除法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// not pure, can throw exception</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naiveDiv</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x / y</span><br><span class="line"></span><br><span class="line">naiveDiv(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// java.lang.ArithmeticException: / by zero</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pure</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Option</span>[<span class="type">Int</span>] = </span><br><span class="line">  <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="type">None</span> <span class="keyword">else</span> <span class="type">Some</span>(x / y)</span><br><span class="line"></span><br><span class="line">div(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// res13: Option[Int] = None</span></span><br><span class="line">div(<span class="number">8</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// res14: Option[Int] = Some(4)</span></span><br></pre></td></tr></table></figure><p>现在我们不仅要做除法，还要让用户输入这两个值，我们需要一个<code>parseInt</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naiveParseInt</span></span>(s: <span class="type">String</span>): <span class="type">Int</span> = s.toInt</span><br><span class="line"></span><br><span class="line">naiveParseInt(<span class="string">"12"</span>)</span><br><span class="line"><span class="comment">// res17: Int = 42</span></span><br><span class="line">naiveParseInt(<span class="string">"aa"</span>)</span><br><span class="line"><span class="comment">// java.lang.NumberFormatException: For input string: "aa"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Try</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseInt</span></span>(s: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Try</span>(s.toInt).toOption</span><br><span class="line"></span><br><span class="line">parseInt(<span class="string">"42"</span>)</span><br><span class="line"><span class="comment">// res24: Option[Int] = Some(42)</span></span><br><span class="line">parseInt(<span class="string">"aa"</span>)</span><br><span class="line"><span class="comment">// res25: Option[Int] = None</span></span><br></pre></td></tr></table></figure><p>现在我们把他们串起来，自然地，我们也需要返回一个<code>Option[Int]</code>来涵盖结果的成功和失败。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stringDiv</span></span>(a: <span class="type">String</span>, b: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Int</span>] = </span><br><span class="line">  parseInt(a).flatMap &#123; x =&gt; </span><br><span class="line">    parseInt(b).flatMap &#123; y =&gt; </span><br><span class="line">      div(x, y)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">stringDiv(<span class="string">"10"</span>, <span class="string">"2"</span>)</span><br><span class="line"><span class="comment">// res28: Option[Int] = Some(5)</span></span><br><span class="line">stringDiv(<span class="string">"a"</span>, <span class="string">"1"</span>)</span><br><span class="line"><span class="comment">// res29: Option[Int] = None</span></span><br><span class="line">stringDiv(<span class="string">"22"</span>, <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">// res30: Option[Int] = None</span></span><br></pre></td></tr></table></figure><p><code>stringDiv</code>做了这些事情：</p><ol><li><code>parseInt(a)</code>返回一个<code>None</code>或者<code>Some(x)</code>；</li><li>如果是<code>Some</code>，将<code>Some</code>内的值<code>x</code>取出来，传递给后面的函数；</li><li><code>parseInt(b)</code>返回一个<code>None</code>或者<code>Some(y)</code>；</li><li>如果是<code>Some</code>，将<code>Some</code>内的值<code>y</code>取出来，继续传给后面的函数；</li><li>计算<code>div(x, y)</code>，返回最终结果<code>None</code>或者<code>Some(x)</code>。</li></ol><p>手动使用<code>flatMap</code>拼接比较繁琐，也不太容易看得清。Scala为我们提供了一个语法糖：for-comprehension。</p><p>下面的<code>stringDiv2</code>与stringDiv是等价的，编译器会帮我们把for-comprehension编译成<code>flatMap</code>（和<code>map</code>）的调用链。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stringDiv2</span></span>(a: <span class="type">String</span>, b: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Int</span>] = </span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    x &lt;- parseInt(a)</span><br><span class="line">    y &lt;- parseInt(b)</span><br><span class="line">    res &lt;- div(x, y)</span><br><span class="line">  &#125; <span class="keyword">yield</span> res</span><br></pre></td></tr></table></figure><p>审视一下上面的例子，我们确确实实地将计算给串起来了。</p><p><code>flatMap</code>起了什么作用呢？</p><p><strong><code>flatMap</code>将上游<code>Option[Int]</code>中的值抽出来，执行运算，再塞进<code>Option[Int]</code>中，传递给下游。</strong></p><p>因为<code>div</code>只能接受<code>Int</code>，而传给<code>div</code>的是<code>Option[Int]</code>，所以我们不能用简单的函数组合来解决问题。</p><table><thead><tr><th>using <code>compose</code></th><th>using <code>flatMap</code></th></tr></thead><tbody><tr><td><code>naiveParseInt: String =&gt; Int</code></td><td><code>parseInt: String =&gt; Option[Int]</code></td></tr><tr><td><code>naiveDiv: (Int, Int) =&gt; Int</code></td><td><code>div: (Int, Int) =&gt; Option[Int]</code></td></tr><tr><td><code>(a, b) =&gt; naiveDiv(naiveParseInt(a),naiveParseInt(b))</code></td><td>see <code>stringDiv2</code></td></tr></tbody></table><h2 id="monad的定义"><code>Monad</code>的定义</h2><p>在上述的例子中，我们使用<code>flatMap</code>将<code>Option[Int]</code>串了起来。</p><p>如果我们只有<code>Int</code>，<code>flatMap</code>岂不是毫无作用？</p><p>没关系，我们还有<code>unit</code>，可以把一个值<code>A</code>变成<code>F[A]</code>，可以视作将一个纯粹的值提升到了monad上下文中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monad</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="comment">// `unit` is also known as `pure` or `return`</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">A</span>](value: <span class="type">A</span>): <span class="type">F</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](ma: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">F</span>[<span class="type">B</span>]): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们说过，monad是特殊的functor。换言之，所有的monad都是functor，不是所有的functor都是monad。</p><p>因为我们可以使用<code>unit</code>和<code>flatMap</code>实现<code>map</code>，有了<code>map</code>，自然就是functor。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](ma: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = ???</span><br></pre></td></tr></table></figure><p>这个实现是显然且唯一的，答案在文章末尾。</p><h2 id="小结">小结</h2><p>这次我们通过一个简单的例子阐述了monad的作用，并写下了monad的一种形式化定义。</p><p>接下来，我们还会研究monad定律，研究monad的不同表现形式。</p><p>最后，我们会研究大量的monad实例，来加深理解。</p><h2 id="reference">Reference</h2><ol><li><a href="https://bartoszmilewski.com/2016/11/21/monads-programmers-definition/" target="_blank" rel="noopener">Monads: Programmer’s Definition</a></li><li><a href="https://underscore.io/books/scala-with-cats/" target="_blank" rel="noopener">Monads – Chapter 3 in <em>Scala with Cats</em></a></li><li><a href="https://www.manning.com/books/functional-programming-in-scala" target="_blank" rel="noopener">Monad – Chapter 11 in <em>Functional Programming in Scala</em></a></li></ol><h2 id="答案：通过unit和flatmap实现map">答案：通过<code>unit</code>和<code>flatMap</code>实现<code>map</code></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](ma: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>] = </span><br><span class="line">  flatMap(ma)(a =&gt; unit(f(a)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;Monad ---- “the m-word”，“a monoid in the category of endofunctors”.&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;see &lt;a href=&quot;https://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A monad is just a monoid in the category of endofunctors, what’s the problem?&lt;/a&gt; for fun&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在FP的路上，不可避免地会碰到monad这个拦路虎。绕是绕不过去的，那就学咯。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“我看了几十篇关于monad的文章，还是没懂。” – 某不知名FP爱好者&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这篇文章也不是silver bullet，我只希望读者在读过以后，对monad能有个大致的、模糊的印象，今后能够持续地从多个角度去审视这个概念，加深认识。&lt;/p&gt;
&lt;h2 id=&quot;什么是monad&quot;&gt;什么是monad&lt;/h2&gt;
&lt;p&gt;我们在说functor的时候，有一个不那么准确的定义：&lt;strong&gt;有&lt;code&gt;map&lt;/code&gt;的，就是functor&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当我们这样定义的时候，我们其实是在泛化&lt;code&gt;map&lt;/code&gt;，将它们的共性抽象出来，这个抽象就是functor。&lt;/p&gt;
&lt;p&gt;同样地，&lt;code&gt;flatMap&lt;/code&gt;也出现在很多地方（比如&lt;code&gt;List&lt;/code&gt;，&lt;code&gt;Option&lt;/code&gt;，&lt;code&gt;Future&lt;/code&gt;，&lt;code&gt;Either&lt;/code&gt;等等等），我们自然也想把共性抽象出来，这个抽象，就是monad。所以可以类似地说：&lt;strong&gt;有&lt;code&gt;flatMap&lt;/code&gt;的，就是monad&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;好吧，如果要正式一点，引用下&lt;em&gt;scala with cats&lt;/em&gt;里的定义：&lt;strong&gt;monad是一种将计算按顺序排列起来的机制（a mechanism for sequencing computations）&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Scala" scheme="http://duanyifu.com/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://duanyifu.com/tags/Functional-Programming/"/>
    
      <category term="Monad" scheme="http://duanyifu.com/tags/Monad/"/>
    
  </entry>
  
  <entry>
    <title>Functor in Functional Programming</title>
    <link href="http://duanyifu.com/2019/09/30/functor-in-FP/"/>
    <id>http://duanyifu.com/2019/09/30/functor-in-FP/</id>
    <published>2019-09-30T07:22:56.000Z</published>
    <updated>2019-10-31T10:15:17.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是functor？">什么是Functor？</h2><p>先看一段代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> i ** <span class="number">2</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">i</span> =&gt;</span> i ** i)</span><br><span class="line"><span class="comment">// [1, 16, 81]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scala</span></span><br><span class="line">Right(<span class="number">3</span>).map(<span class="function"><span class="params">n</span> =&gt;</span> n + <span class="string">" cats!"</span>)</span><br><span class="line"><span class="comment">// res2: Either[Nothing, String] = Right("3 cats!")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// java</span></span><br><span class="line">Optional.empty().map(n -&gt; <span class="string">"hi, "</span> + n);</span><br><span class="line"><span class="comment">// Optional.empty</span></span><br></pre></td></tr></table></figure><p>这些类型都有<code>map</code>，而且看上去<code>map</code>的作用好像都相同。</p><p>事实上，它们确实相同。</p><p>不那么准确地说，任何东西只要有<code>map</code>，我们就可以将它视作functor。</p><p>要研究functor，我们需要转变一下（命令式）思路。</p><p>可以将functor想象成一个容器，容器里放了一些元素。</p><p><code>map</code>并不是对容器进行一次遍历（traverse），而是对容器内的元素做一个变换（transform）。</p><p>如果有多个<code>map</code>被串起来了，则会按照先后顺序，进行变换。（这里顺序是很重要的，下面会细说）</p><a id="more"></a><h2 id="functor的定义">Functor的定义</h2><p>我们可以将functor定义为一个trait：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Functor</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">F</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个数据结构，我们只需要让其继承这个trait，并实现<code>map</code>，就可以把它当作functor来用了。</p><p>比如：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listFunctor: <span class="type">Functor</span>[<span class="type">List</span>] = <span class="keyword">new</span> <span class="type">Functor</span>[<span class="type">List</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] = as.map(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>functor法则是不言自明的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(s)(a =&gt; a) == s</span><br></pre></td></tr></table></figure><p>即，用identity函数映射一个结构s，结果仍然是s。</p><p>观察一下，我们可以发现functor能做的事仅有：</p><ul><li>将容器内的元素进行变换（transform）</li></ul><p>除此之外，都不可以。</p><p>比如这些事情，functor都是做不到的：</p><ol><li>改变容器本身：<code>List</code>变成一个<code>Set</code>，<code>Some</code>变成一个<code>None</code>；</li><li>将元素取出来：Functor[A] 变成 A；</li><li>改变元素：移除<code>List</code>的第一个元素；</li><li>将元素聚合成一个：比如sum起来；</li><li>抛出异常。</li></ol><h3 id="非常规functor的例子">非常规functor的例子</h3><h4 id="future">Future</h4><p><code>Future</code>也有<code>map</code>方法，也是一个functor 。</p><p><code>map</code>会将<strong>异步</strong>计算应用于<code>Future</code>内的元素，多个<code>map</code>会按照顺序先后执行。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.&#123;<span class="type">Await</span>, <span class="type">Future</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FutureUsage</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> future: <span class="type">Future</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="type">Future</span>(<span class="number">0</span>)</span><br><span class="line">      .map(_ + <span class="number">10</span>)</span><br><span class="line">      .map(_ * <span class="number">4</span>)</span><br><span class="line">      .map(_ + <span class="number">2</span>)</span><br><span class="line">      .map(<span class="string">"The Ultimate Answer to Life, The Universe and Everything is..."</span> + _ + <span class="string">"!"</span>)</span><br><span class="line">  <span class="type">Await</span>.result(future, <span class="number">1.</span>second)</span><br><span class="line">  <span class="comment">// "The Ultimate Answer to Life, The Universe and Everything is...42!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们使用<code>Future</code>的时候，其实我们并不清楚<code>Future</code>内部状态。</p><ul><li><p>如果<code>Future</code>已经完成了，那么我们的<code>map</code>就会立刻被调用。</p></li><li><p>如果<code>Future</code>尚未完成，我们的<code>map</code>会被放到默认的<code>ExecutionContext</code>里的队列中，等着，之后再执行。</p></li></ul><p>对于<code>Future</code>上的<code>map</code>，我们并不知道<code>map</code><strong>何时</strong>会执行，我们只知道<code>map</code>执行的<strong>顺序</strong>。</p><h4 id="function-别急-先收起你头上的？？？">Function（别急，先收起你头上的？？？）</h4><p>考虑这种情况，我们有一个<code>f: T =&gt; A</code>和一个<code>p: A =&gt; B</code>，想要得到一个<code>g: T =&gt; B</code>。</p><p>你一定会说，这个简单，基本的function composition嘛。</p><p>这里我们需要换一个视角：</p><ol><li>将<code>T =&gt; A</code>看作<code>SomeFunc[A]</code></li><li>给<code>SomeFunc[A]</code>一个<code>A =&gt; B</code></li><li>得到一个<code>SomeFunc[B]</code></li></ol><p>怎么样，我们是不是对<code>SomeFunc</code>进行了一次<code>map</code>。<br>看一段例子，这里我们用到了cats这个库，cats为Scala提供了很多函数式的抽象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cats.instances.function._</span><br><span class="line"><span class="keyword">import</span> cats.syntax.functor._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func1: <span class="type">Int</span> =&gt; <span class="type">String</span> =</span><br><span class="line">  (x: <span class="type">Int</span>) =&gt; x.toString</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> func2: <span class="type">String</span> =&gt; <span class="type">String</span> =</span><br><span class="line">  (y: <span class="type">String</span>) =&gt; y + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// three ways to compose functions</span></span><br><span class="line"><span class="comment">// 1. using map</span></span><br><span class="line">(func1.map(func2))(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 2. using andThen</span></span><br><span class="line">(func1.andThen(func2))(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 3. by hand</span></span><br><span class="line">func2(func1(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>当我们写下<code>val f = f1.map(f2).map(f3).map(f4)</code>的时候，这一串<code>map</code>就是将一系列的计算’串’在了一起，等到<code>f</code>被调用的时候再执行（和<code>Future</code>一样）。</p><p>PS: 这个我们其实叫它Reader Functor（详细内容可以看references中第一篇）。</p><h2 id="小结">小结</h2><p>functor是FP中非常非常基础的抽象，就像monoid一样，看上去对我们日常的编程并没有太大的作用（其实我们可以根据functor构建通用的<code>zip</code>和<code>unzip</code>）。不过没关系，之后我们还会研究一些functor的特例，monad和applicative functor，这些是十分实用且普遍的。</p><p>PS：你可以在范畴论中找到functor的原型，functor是范畴的态射（morphism of categories），会将一个范畴中的morphism和object映射到另一个范畴中。</p><h2 id="references">References</h2><ol><li><a href="https://bartoszmilewski.com/2015/01/20/functors/" target="_blank" rel="noopener">Functors – Chapter 8 in <em>the Category Theory for Programmers</em></a></li><li><a href="https://underscore.io/books/scala-with-cats/" target="_blank" rel="noopener">Functors – Chapter 3 in <em>Scala with Cats</em></a></li><li><a href="https://www.manning.com/books/functional-programming-in-scala" target="_blank" rel="noopener">Monad – Chapter 11 in <em>Functional Programming in Scala</em></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是functor？&quot;&gt;什么是Functor？&lt;/h2&gt;
&lt;p&gt;先看一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;i&lt;/span&gt; =&amp;gt;&lt;/span&gt; i ** &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;i&lt;/span&gt; =&amp;gt;&lt;/span&gt; i ** i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [1, 16, 81]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// scala&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Right(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;).map(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;n&lt;/span&gt; =&amp;gt;&lt;/span&gt; n + &lt;span class=&quot;string&quot;&gt;&quot; cats!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// res2: Either[Nothing, String] = Right(&quot;3 cats!&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Optional.empty().map(n -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;hi, &quot;&lt;/span&gt; + n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Optional.empty&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些类型都有&lt;code&gt;map&lt;/code&gt;，而且看上去&lt;code&gt;map&lt;/code&gt;的作用好像都相同。&lt;/p&gt;
&lt;p&gt;事实上，它们确实相同。&lt;/p&gt;
&lt;p&gt;不那么准确地说，任何东西只要有&lt;code&gt;map&lt;/code&gt;，我们就可以将它视作functor。&lt;/p&gt;
&lt;p&gt;要研究functor，我们需要转变一下（命令式）思路。&lt;/p&gt;
&lt;p&gt;可以将functor想象成一个容器，容器里放了一些元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;并不是对容器进行一次遍历（traverse），而是对容器内的元素做一个变换（transform）。&lt;/p&gt;
&lt;p&gt;如果有多个&lt;code&gt;map&lt;/code&gt;被串起来了，则会按照先后顺序，进行变换。（这里顺序是很重要的，下面会细说）&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Scala" scheme="http://duanyifu.com/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://duanyifu.com/tags/Functional-Programming/"/>
    
      <category term="Functor" scheme="http://duanyifu.com/tags/Functor/"/>
    
  </entry>
  
  <entry>
    <title>浅谈covariance和contravariance</title>
    <link href="http://duanyifu.com/2019/08/30/variance/"/>
    <id>http://duanyifu.com/2019/08/30/variance/</id>
    <published>2019-08-30T13:05:56.000Z</published>
    <updated>2019-09-01T10:51:11.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些定义">一些定义</h2><p>考虑类型<code>A</code>和<code>C</code>，以及泛型构造器<code>F&lt;T&gt;</code>：</p><ul><li><strong>如果我们在一个需要<code>A</code>的地方，总能使用<code>C</code>，我们就可以说<code>C</code>是<code>A</code>的子类型（subtype）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，记作<code>C &lt;: A</code>。</strong></li><li><strong>如果F是协变的（covariant），且<code>C &lt;: A</code>，则有<code>F&lt;C&gt; &lt;: F&lt;A&gt;</code>。</strong></li><li><strong>如果F是逆变的（contravariant），且<code>C &lt;: A</code>，则有<code>F&lt;A&gt; &lt;: F&lt;C&gt;</code>。</strong></li><li><strong>如果F是不变的（invariant），无论<code>A</code>与<code>C</code>是什么关系，<code>F&lt;C&gt;</code> 与 <code>F&lt;A&gt;</code>都没有关系。</strong></li></ul><h2 id="collection视角">Collection视角</h2><p>先举用例子来看看Collection的型变规则。</p><p><code>Duck</code>是<code>Bird</code>的子类，<code>Bird</code>是<code>Animal</code>的子类，记作<code>Duck &lt;: Bird &lt;: Animal</code>。</p><p>TypeScript中的<code>Array</code>是协变的（covariant）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123; name: <span class="built_in">String</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> Bird <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="comment">// not all animals can fly</span></span><br><span class="line">    fly: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">String</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Duck <span class="keyword">extends</span> Bird &#123;</span><br><span class="line">    <span class="comment">// not all birds can swim</span></span><br><span class="line">    swim: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">String</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> aDog: Animal = &#123;</span><br><span class="line">    name: <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> aBird: Bird = &#123;</span><br><span class="line">    name: <span class="string">"Owl"</span>,</span><br><span class="line">    fly: <span class="function"><span class="params">()</span> =&gt;</span> name + <span class="string">" is flying!"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> aDuck: Duck = &#123;</span><br><span class="line">    name: <span class="string">"Donald"</span>, </span><br><span class="line">    fly: <span class="function"><span class="params">()</span> =&gt;</span> name + <span class="string">" is flying!"</span>,</span><br><span class="line">    swim: <span class="function"><span class="params">()</span> =&gt;</span> name + <span class="string">" is swiming!"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Legal; Array is covariant, expecting an Array&lt;Animal&gt;, given an Array&lt;Bird&gt; </span></span><br><span class="line"><span class="keyword">const</span> animals: <span class="built_in">Array</span>&lt;Animal&gt; = [aDuck, aBird]; </span><br><span class="line"><span class="comment">// Illegal; expecting an Array&lt;Bird&gt;, given an Array&lt;Animal&gt;</span></span><br><span class="line"><span class="keyword">const</span> birds: <span class="built_in">Array</span>&lt;Bird&gt; = [aDuck, aDog];</span><br></pre></td></tr></table></figure><a id="more"></a><p>函数传入参数同样遵循这个规则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">birdsFly</span>(<span class="params">birds: <span class="built_in">Array</span>&lt;Bird&gt;</span>) </span>&#123;</span><br><span class="line">    birds.forEach(<span class="function"><span class="params">b</span> =&gt;</span> b.fly())</span><br><span class="line">&#125;</span><br><span class="line">birdsFly(animals) <span class="comment">// Illegal</span></span><br><span class="line">birdsFly(birds) <span class="comment">// Legal, type matches</span></span><br><span class="line">birdsFly(ducks) <span class="comment">// Legal, Array&lt;Duck&gt; &lt;: Array&lt;Bird&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，Java的<code>List</code>是不变的（invariant）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Bird&gt; birds = <span class="keyword">new</span> ArrayList&lt;Duck&gt;(); <span class="comment">// Illegal</span></span><br><span class="line">List&lt;Bird&gt; birds = <span class="keyword">new</span> ArrayList&lt;Bird&gt;(); <span class="comment">// Legal</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">birdsFly</span><span class="params">(List&lt;Bird&gt; birds)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">birdsFly(animals); <span class="comment">// Illegal</span></span><br><span class="line">birdsFly(birds); <span class="comment">// Legal</span></span><br><span class="line">birdsFly(ducks); <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure><p>当然，我们可以用bounded wildcards在使用时去除不变性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Bird&gt; coList = <span class="keyword">new</span> ArrayList&lt;Duck&gt;(); <span class="comment">// Legal; covariant</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Bird&gt; contraList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;(); <span class="comment">// Legal; contravariant</span></span><br></pre></td></tr></table></figure><p><em>Effective Java</em>中提到的PECS（producer extends，consumer super），就是说，如果你接收一个Collection：</p><ul><li>只读其中的元素（Collection是producer），那么你最好接受一个协变的Collection；</li><li>反之，如果你只写入<code>List</code>（Collection是consumer），那么你最好接受一个逆变的Collection。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">namesOfBirds</span><span class="params">(List&lt;? extends Bird&gt; birds)</span> </span>&#123;</span><br><span class="line">  birds.forEach(bird -&gt; System.out.println(bird.getName()));</span><br><span class="line">&#125;</span><br><span class="line">namesOfBird(ducks); <span class="comment">// Legal; covariant</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addAOwl</span><span class="params">(List&lt;? <span class="keyword">super</span> Bird&gt; birds)</span> </span>&#123;</span><br><span class="line">  Bird aOwl = <span class="keyword">new</span> Bird(<span class="string">"owl"</span>);</span><br><span class="line">  birds.add(aOwl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// It is natural to add a owl into a List&lt;Animal&gt;</span></span><br><span class="line">addAOwl(animals) <span class="comment">// Legal; contravariant</span></span><br></pre></td></tr></table></figure><h2 id="function-type">Function Type</h2><p>容器类型的型变其实是比较符合直觉的，函数类型就很反直觉了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T1</span>, +<span class="type">R</span>]</span></span><br></pre></td></tr></table></figure><p>这是Scala标准库定义的单参函数的trait（可以理解为interface），类型为<code>T1 -&gt; R</code>，其中<code>T1</code>是逆变的，<code>R</code>是协变的<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p><p>But why？？？</p><p>回想一下，型变规则决定了我们能使用什么样的子类型，<strong>子类型决定了我们能在一个期望X的地方，安全地使用另一个类型Y</strong>（X的子类型）。</p><p>So，既然函数类型也是一种类型，我们当然也要知道函数类型的子类型咯，对吧？</p><p>那么对于函数类型<code>Bird -&gt; Bird</code>，根据trait定义，<code>Animal -&gt; Duck</code>就是它的子类型。</p><p>Weird, right?</p><p>假设我们有高阶函数<code>f: (Bird -&gt; Bird) -&gt; String</code>（返回什么我们并不关心）。</p><p>将传入的函数记作<code>g</code>，尝试在<code>g</code>的参数上用子（超）类型进行替代:</p><p><strong>1. 如果<code>g: Duck -&gt; Bird</code>，<code>f(g)</code>会怎样？</strong></p><p><code>f</code>已知<code>g</code>接受<code>Bird</code>，于是<code>f</code>调用<code>g</code>的时候，传给<code>g</code>一个<code>Bird</code>。</p><p>然而，<code>g</code>只能处理<code>Bird</code>的一个子类型<code>Duck</code>，如果接收到一个<code>Swan</code>，<code>g</code>会崩溃。</p><p>所以参数类型不可以用子类型替代。</p><p><strong>2. 如果<code>g: Bird -&gt; Animal</code>，<code>f(g)</code>会怎样？</strong></p><p><code>f</code>已知<code>g</code>返回<code>Bird</code>，于是<code>f</code>会将<code>g</code>的返回值当作<code>Bird</code>来使用。</p><p>但是现在<code>g</code>会返回一个不是<code>Bird</code>的<code>Animal</code>，比如<code>Dog</code>，那么<code>f</code>会崩溃。</p><p>所以返回类型不可以用超类型替代。</p><p><strong>3. 如果<code>g: Animal -&gt; Duck</code>，<code>f(g)</code>又如何呢？</strong></p><p><code>f</code>已知<code>g</code>接收<code>Bird</code>，所以传给<code>g</code>一个<code>Bird</code>，<code>g</code>可以正常处理<code>Bird</code>并返回<code>Duck</code>，没有问题。</p><p><code>f</code>已知<code>g</code>返回<code>Bird</code>，所以将<code>g</code>返回的<code>Duck</code>当作<code>Bird</code>来用，所有<code>Duck</code>都是<code>Bird</code>，也没问题。</p><p>所以，在一个期望<code>(Bird -&gt; Bird)</code>的地方，我们总是可以使用<code>(Animal -&gt; Duck)</code>。</p><p>即<code>(Animal -&gt; Duck)</code>是<code>(Bird -&gt; Bird)</code>的子类型。</p><p>也就是说，<strong>参数类型可以用超类型替代，返回类型可以用子类型替代</strong>。</p><p>形式化一点，就是对于函数类型构造器<code>-&gt;</code>，接收参数逆变且返回参数协变时，仍然可以保证类型安全。</p><p>或者说：<strong>对于函数p和q，当p的参数更general，返回值更specific时，p可以安全地替代q</strong>。</p><p>其实，Java8的<code>Function</code>接口的型变规则也是这样的，<code>compose</code>和<code>andThen</code>都是接收了一个<code>Function&lt;? super V, ? extends T&gt;</code>，恰恰正是<strong>参数逆变，返回值协变</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// see http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/function/Function.java</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="references">References</h2><ol><li><a href="https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance" target="_blank" rel="noopener">What are covariance and contravariance?</a></li><li><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="noopener">Covariance and contravariance (computer science)</a></li><li><a href="https://medium.com/@michalskoczylas/covariance-contravariance-and-a-little-bit-of-typescript-2e61f41f6f68" target="_blank" rel="noopener">Covariance, contravariance and a little bit of TypeScript</a></li><li><a href="https://briangordon.github.io/2014/09/covariance-and-contravariance.html" target="_blank" rel="noopener">Covariance and contravariance rules in Java</a></li><li><a href="https://docs.scala-lang.org/tour/variances.html" target="_blank" rel="noopener">Variances - <em>Tour of Scala</em></a></li><li><a href="https://bartoszmilewski.com/2015/02/03/functoriality/" target="_blank" rel="noopener">Functoriality - <em>Categories for Programmers</em></a></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>需要注意的是，子类（subclass）和子类型（subtype）不是一回事。 <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>Scala中，<code>F[+A]</code>代表协变，<code>F[-A]</code>代表逆变，<code>F[A]</code>代表不变。 <a href="#fnref2" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一些定义&quot;&gt;一些定义&lt;/h2&gt;
&lt;p&gt;考虑类型&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;C&lt;/code&gt;，以及泛型构造器&lt;code&gt;F&amp;lt;T&amp;gt;&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果我们在一个需要&lt;code&gt;A&lt;/code&gt;的地方，总能使用&lt;code&gt;C&lt;/code&gt;，我们就可以说&lt;code&gt;C&lt;/code&gt;是&lt;code&gt;A&lt;/code&gt;的子类型（subtype）&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;，记作&lt;code&gt;C &amp;lt;: A&lt;/code&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果F是协变的（covariant），且&lt;code&gt;C &amp;lt;: A&lt;/code&gt;，则有&lt;code&gt;F&amp;lt;C&amp;gt; &amp;lt;: F&amp;lt;A&amp;gt;&lt;/code&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果F是逆变的（contravariant），且&lt;code&gt;C &amp;lt;: A&lt;/code&gt;，则有&lt;code&gt;F&amp;lt;A&amp;gt; &amp;lt;: F&amp;lt;C&amp;gt;&lt;/code&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果F是不变的（invariant），无论&lt;code&gt;A&lt;/code&gt;与&lt;code&gt;C&lt;/code&gt;是什么关系，&lt;code&gt;F&amp;lt;C&amp;gt;&lt;/code&gt; 与 &lt;code&gt;F&amp;lt;A&amp;gt;&lt;/code&gt;都没有关系。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;collection视角&quot;&gt;Collection视角&lt;/h2&gt;
&lt;p&gt;先举用例子来看看Collection的型变规则。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Duck&lt;/code&gt;是&lt;code&gt;Bird&lt;/code&gt;的子类，&lt;code&gt;Bird&lt;/code&gt;是&lt;code&gt;Animal&lt;/code&gt;的子类，记作&lt;code&gt;Duck &amp;lt;: Bird &amp;lt;: Animal&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;TypeScript中的&lt;code&gt;Array&lt;/code&gt;是协变的（covariant）：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Animal &amp;#123; name: &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Bird &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Animal &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// not all animals can fly&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fly: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Duck &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Bird &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// not all birds can swim&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swim: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; aDog: Animal = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; aBird: Bird = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Owl&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fly: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; name + &lt;span class=&quot;string&quot;&gt;&quot; is flying!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; aDuck: Duck = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Donald&quot;&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fly: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; name + &lt;span class=&quot;string&quot;&gt;&quot; is flying!&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swim: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; name + &lt;span class=&quot;string&quot;&gt;&quot; is swiming!&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Legal; Array is covariant, expecting an Array&amp;lt;Animal&amp;gt;, given an Array&amp;lt;Bird&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; animals: &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;&amp;lt;Animal&amp;gt; = [aDuck, aBird]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Illegal; expecting an Array&amp;lt;Bird&amp;gt;, given an Array&amp;lt;Animal&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; birds: &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;&amp;lt;Bird&amp;gt; = [aDuck, aDog];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Java" scheme="http://duanyifu.com/tags/Java/"/>
    
      <category term="Functional Programming" scheme="http://duanyifu.com/tags/Functional-Programming/"/>
    
      <category term="TypeScript" scheme="http://duanyifu.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>Monoid in Functional Programming</title>
    <link href="http://duanyifu.com/2019/07/28/monoid-in-FP/"/>
    <id>http://duanyifu.com/2019/07/28/monoid-in-FP/</id>
    <published>2019-07-28T11:31:56.000Z</published>
    <updated>2020-01-04T07:10:09.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="monoid-是什么？">Monoid 是什么？</h2><p>我们先看两组例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string concatenation</span></span><br><span class="line">concat(<span class="string">"foo"</span>,<span class="string">"bar"</span>) == <span class="string">"foobar"</span></span><br><span class="line">concat(<span class="string">""</span>, <span class="string">"latte"</span>) == concat(<span class="string">"latte"</span>, <span class="string">""</span>) == <span class="string">"latte"</span></span><br><span class="line">concat(<span class="string">"a"</span>, concat(<span class="string">"b"</span>, <span class="string">"c"</span>)) == concat(concat(<span class="string">"a"</span>, <span class="string">"b"</span>), <span class="string">"c"</span>) == <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// integer addition</span></span><br><span class="line"><span class="number">3</span> + <span class="number">5</span> == <span class="number">8</span></span><br><span class="line"><span class="number">0</span> + <span class="number">42</span> == <span class="number">42</span> + <span class="number">0</span> == <span class="number">42</span></span><br><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="number">3</span>) == (<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span> == <span class="number">6</span></span><br></pre></td></tr></table></figure><p>我们可以发现，这两组操作其实有着相同的模式：</p><ul><li>有一个“零值”，记作<code>zero</code>，例子中分别是<code>空串</code>和<code>0</code></li><li>有一个二元操作符，记作<code>op</code>，例子中分别是<code>concat</code>和<code>+</code></li><li><code>op</code>满足结合律（associativity），即<code>op(x, op(y, z)) == op(op(x, y), z)</code></li><li>零值是单位元，即<code>op(zero, x) == op(x, zero) == x</code></li></ul><a id="more"></a><p>那么我们可以这样表示monoid：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(m: <span class="type">A</span>, n: <span class="type">A</span>): <span class="type">A</span> <span class="comment">// 满足 op(x, op(y, z)) == op(op(x, y), z)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span> <span class="comment">// 满足 op(zero, x) == op(x, zero) == x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，monoid是十分普遍的，比如：</p><ol><li>乘法，单位元是1</li><li>布尔运算<code>&amp;&amp;</code>，单位元是<code>true</code></li><li>求<code>Integer</code>的最大值<code>max</code>，单位元是<code>Integer.MIN_VALUE</code></li><li><code>List</code>的连接，单位元是<code>Nil（空列表）</code></li><li>自函数（参数与返回值的类型相同，即类型为<code>A =&gt; A</code>的函数）的组合<code>compose</code>，单位元是<code>id</code></li></ol><p>第5个并不是那么显而易见，实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">endoMonoid</span></span>[<span class="type">A</span>]: <span class="type">Monoid</span>[<span class="type">A</span> =&gt; <span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">A</span> =&gt; <span class="type">A</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(f: <span class="type">A</span> =&gt; <span class="type">A</span>, g: <span class="type">A</span> =&gt; <span class="type">A</span>): <span class="type">A</span> =&gt; <span class="type">A</span> = </span><br><span class="line">    g compose f <span class="comment">// you can choose (g compose f) or (f compose g)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span> =&gt; <span class="type">A</span> = </span><br><span class="line">    (x =&gt; x) <span class="comment">// aka. id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么monoid是什么？</p><p><strong>一个可结合的二元操作符和一个单位元元素，构成一个monoid。</strong></p><h2 id="monoid-有什么用？">Monoid 有什么用？</h2><p>Monoid是一种抽象，我们总是可以通过抽象来写出<strong>更加通用的代码</strong>：事实上，我们可以不关心monoid里的具体类型，直接写出可以对任何monoid都有效的代码。</p><h3 id="计算的灵活性">计算的灵活性</h3><p>事实上，对于monoid，我们并不关心计算发生的顺序，结合律保证了结果的一致：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. foldRight</span></span><br><span class="line">a + (b + (c + (d + (e + (f + (g + h))))))</span><br><span class="line"><span class="comment">// 2. foldLeft</span></span><br><span class="line">((((((a + b) + c) + d) + e) + f) + g) + h</span><br><span class="line"><span class="comment">// 3. run in parallel</span></span><br><span class="line">(a + b + c) + (d + e + f) + (g + h + <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 4. fold like a binary tree</span></span><br><span class="line">((a + b) + (c + d)) + ((e + f) + (g + h))</span><br></pre></td></tr></table></figure><p>我们可以用任何顺序进行计算，甚至直接将每个任务分派给不同节点开始并行计算！</p><h3 id="list的折叠">List的折叠</h3><p>仔细观察，你会发现当我们对一个<code>List</code>进行<code>fold</code>操作（aka <code>reduce</code> in JavaScript/Python）时，传给fold的操作，恰好是monoid的<code>op</code>和<code>zero</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foldLeft(<span class="number">0</span>)((x, y) =&gt; x + y) == </span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foldLeft(intAddtion.zero)(intAddtion.op)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intAddtionMonoid: <span class="type">Monoid</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以写一个更加通用的函数，接收一个<code>List[A]</code>和一个<code>Monoid[A]</code>，并用这个monoid去折叠：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concatenate</span></span>[<span class="type">A</span>](as: <span class="type">List</span>[<span class="type">A</span>], m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">  as.foldLeft(m.zero)(m.op)</span><br></pre></td></tr></table></figure><p>甚至可以将<code>List[A]</code> map 成<code>List[B]</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], m: <span class="type">Monoid</span>[<span class="type">B</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">B</span> = </span><br><span class="line">  as.foldLeft(m.zero)(b =&gt; a =&gt; m.op(b, f(a)))</span><br></pre></td></tr></table></figure><h3 id="通用折叠">通用折叠</h3><p>事实上，对于所有的可折叠数据结构，我们都可以忽略其具体结构，直接用monoid进行折叠。</p><p>比如，我们有一个存放了<code>Int</code>的可折叠结构，计算其总和：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints.foldRight(intAddtionMonoid.zero)(intAddtionMonoid.op)</span><br></pre></td></tr></table></figure><p>我们并不关心，这个ints，究竟是<code>List</code>还是<code>Array</code>还是<code>Vector</code>，甚至可能是<code>Tree</code>或者<code>Stream</code>！</p><p>对于这些结构，我们给它起个名字，叫做<code>Foldable</code>，我们可以抽象成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Foldable</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(z: <span class="type">B</span>)(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(z: <span class="type">B</span>)(f: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>)(mb: <span class="type">Monoid</span>[<span class="type">B</span>]): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">concatenate</span></span>[<span class="type">A</span>](as: <span class="type">F</span>[<span class="type">A</span>])(m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">    foldLeft(as)(m.zero)(m.op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：<code>F[_]</code>代表一个F是一个类型构造器，接收一个类型参数。比如，<code>F[A]</code>可以具象成<code>List[Int]</code>，<code>Stream[String]</code>等等。</p><h3 id="monoid的组合">Monoid的组合</h3><p><strong>若类型<code>A</code>和<code>B</code>是monoid，那么tuple类型<code>(A, B)</code>同样也是monoid。</strong></p><p>我们只需要将A和B的<code>op</code>和<code>zero</code>组合成<code>tuple</code>就可以了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// am: Monoid[A], bm: Monoid[B]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tupleMonoid</span></span>[<span class="type">A</span>, <span class="type">B</span>]: <span class="type">Monoid</span>[(<span class="type">A</span>, <span class="type">B</span>)] = <span class="keyword">new</span> <span class="type">Monoid</span>[(<span class="type">A</span>, <span class="type">B</span>)] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(t1: (<span class="type">A</span>, <span class="type">B</span>), t2: (<span class="type">A</span>, <span class="type">B</span>)): (<span class="type">A</span>, <span class="type">B</span>) = (t1, t2) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ((a1, b1), (a2, b2)) =&gt; (am.op(a1, a2), bm.op(b1, b2))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: (<span class="type">A</span>, <span class="type">B</span>) = (am.zero, bm.zero)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些monoid的例子">一些Monoid的例子</h2><blockquote><p>There are monoids for all the following:<br>· approximate sets such as the Bloom filter;<br>· set cardinality estimators, such as the HyperLogLog algorithm;<br>· vectors and vector operations like stochastic gradient descent;<br>· quantile estimators such as the t-digest<br>to name but a few.</p><p>– <em>Chapter 9, Scala with Cats</em></p></blockquote><h2 id="闲谈">闲谈</h2><ul><li>Monoid可以算作FP中最简单的纯代数（purely algebraic）结构。</li><li>这种抽象的意义在于——和编程中的任何抽象一样——<strong>消除重复代码</strong>：抽出通用的结构，表达为抽象的类型和接口，从而消除重复。另外，这种抽象还能降低沟通成本。</li><li>Monoid中文名称叫做幺半群，十分拗口，所以全文都没有出现这个名字。</li><li>Monoid名称出自于抽象代数，我们也完全可以叫作AssociateWithIdentity，对我们编程也是毫无影响的。</li></ul><h2 id="references">References</h2><ol><li><p><a href="https://deque.blog/2017/09/13/monoids-what-they-are-why-they-are-useful-and-what-they-teach-us-about-software/" target="_blank" rel="noopener">What monoids teach us about software</a></p></li><li><p><a href="http://comonad.com/reader/wp-content/uploads/2009/07/AllAboutMonoids.pdf" target="_blank" rel="noopener">All about monoids</a></p></li><li><p><a href="https://bartoszmilewski.com/2014/12/05/categories-great-and-small/" target="_blank" rel="noopener">Categories Great and Small</a></p></li><li><p>Chapter 10 of <a href="https://www.manning.com/books/functional-programming-in-scala" target="_blank" rel="noopener">Functional Programming in Scala</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;monoid-是什么？&quot;&gt;Monoid 是什么？&lt;/h2&gt;
&lt;p&gt;我们先看两组例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// string concatenation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;concat(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;concat(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;latte&quot;&lt;/span&gt;) == concat(&lt;span class=&quot;string&quot;&gt;&quot;latte&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;latte&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;concat(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, concat(&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;)) == concat(concat(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// integer addition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) == (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以发现，这两组操作其实有着相同的模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个“零值”，记作&lt;code&gt;zero&lt;/code&gt;，例子中分别是&lt;code&gt;空串&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有一个二元操作符，记作&lt;code&gt;op&lt;/code&gt;，例子中分别是&lt;code&gt;concat&lt;/code&gt;和&lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op&lt;/code&gt;满足结合律（associativity），即&lt;code&gt;op(x, op(y, z)) == op(op(x, y), z)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;零值是单位元，即&lt;code&gt;op(zero, x) == op(x, zero) == x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Scala" scheme="http://duanyifu.com/tags/Scala/"/>
    
      <category term="Functional Programming" scheme="http://duanyifu.com/tags/Functional-Programming/"/>
    
      <category term="Monoid" scheme="http://duanyifu.com/tags/Monoid/"/>
    
  </entry>
  
  <entry>
    <title>Yet Another a Introduction to Y Combinator in Scheme</title>
    <link href="http://duanyifu.com/2017/05/02/ycombinator-in-scheme/"/>
    <id>http://duanyifu.com/2017/05/02/ycombinator-in-scheme/</id>
    <published>2017-05-02T07:31:56.000Z</published>
    <updated>2019-07-28T14:08:22.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言">前言</h3><p>在Lambda演算中，函数是没有名字的（都是匿名函数），那么如果函数没有名字，也就无法在函数体内显式地调用自身，也就无法定义递归函数，Y combinator就是用来解决这个问题的。<br>这篇文章想抛开那些数学概念，用程序语言（Scheme）的形式来讲解我们是如何推导出Y combinator的。</p><p>运行环境：<br>IDE：<a href="https://racket-lang.org/" target="_blank" rel="noopener">DrRacket</a></p><a id="more"></a><h3 id="什么是递归函数？">什么是递归函数？</h3><p>我们以递归函数<code>length</code>为例，<code>length</code>函数接受一个list，返回list的元素数目。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><p><strong>若你熟悉Scheme函数定义，可以跳过本小结后面部分。</strong></p><p><code>(define length</code>，<code>define</code>表达式将一个表达式（表达式即可能是函数也可能是值，在Scheme中并不区分这两点）绑定至一个名字，形式如同<code>(define name func)</code>，之后便可以使用<code>name</code>调用<code>func</code>这个函数。在本定义中，<code>func</code>是后面整个用括号包围的<code>lambda</code>表达式，也就是2-4行。<br><code>(lambda args body)</code>，<code>lambda</code>表达式定义了一个匿名函数，表达式中第二个元素是参数列表，第三个元素是函数体。也就是说，这个匿名函数接受一个参数<code>lst</code>，然后对函数体进行求值。<br><code>(if condition then else)</code>,<code>if</code>表达式，若<code>condition</code>为真，则求值<code>then</code>，若<code>condition</code>为假，则求值<code>else</code>。<br><code>null?</code>接受一个list，判断是否为空。<br><code>add1</code>接受一个值，将其加1后返回，定义如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> add1</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> n)))</span><br><span class="line"></span><br><span class="line">&gt; (add1 3)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><code>rest</code>返回<code>lst</code>去掉第一个元素的剩余部分，其实就是<code>(define rest cdr)</code>。<br>也就是说，<code>length</code>函数接受一个list，若list为空，则返回<code>0</code>，若list非空，则求去掉第一个元素的list长度，并将其加一。求值过程如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">length</span></span> `(<span class="number">1</span> <span class="number">2</span>)) <span class="comment">; `(1 2) is a list has two elements</span></span><br><span class="line">(<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> `(<span class="number">2</span>))) <span class="comment">; `(2) is (rest `(1 2))</span></span><br><span class="line">(<span class="name">add1</span> (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> `()))) <span class="comment">; `() is empty list</span></span><br><span class="line">(<span class="name">add1</span> (<span class="name">add1</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name">add1</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="假如length没有名字？">假如length没有名字？</h3><p>如果我们去掉<code>define</code>，拿出其中的函数定义，是这样。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))) <span class="comment">; length is undefined</span></span><br></pre></td></tr></table></figure><p>**WAIT！！**既然现在没有了<code>length</code>,显然我们也无法在函数体内调用<code>length</code>了。<br>那么我们应该把<code>length</code>换成什么呢？<br>我也不知道。<br>那么我们先试一试换成别的吧。<br>假设我们现在有一个函数<code>id</code>,这个函数什么都不做，只接受一个参数并将其返回，定义如下。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> id</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x) x))</span><br><span class="line"></span><br><span class="line">&gt; (id 1)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>那么，我们把<code>id</code>丢进<code>length</code>定义里面试试：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><p>看上去是个奇怪的函数，这个函数能工作吗？<br>我们可以试一试。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ((lambda (lst)</span><br><span class="line">   (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">       <span class="number">0</span></span><br><span class="line">       (add1 (id (rest lst)))))</span><br><span class="line"> `())</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们喂给这个奇怪的函数一个空list，它居然能返回正确的值！<br>具体原因，请读者先自己思考一下（笑<br>。<br>。<br>。<br>很简单，因为<code>(null? lst)</code>为真，所以<code>if</code>表达式直接返回了<code>0</code>，压根没有对<code>(add1 (id (rest lst)))</code>进行求值。<br>那么我们如果喂<code>(apple)</code>呢，显然这个奇怪的函数并不能返回正确的长度，因为<code>(id (rest lst))</code>无法给出“去掉第一个值的list的长度”。<br>总结一下，这个奇怪的函数：</p><ul><li>若list长度为0，可以正常工作</li><li>若list长度大于0，无法工作</li></ul><p>那么，我们将这个函数叫做<code>length0</code>,代表它对长度为0及0以下（并不存在）的list可以正常工作。</p><h3 id="length1-length2-and">length1, length2, and …</h3><p>好了，我们现在有一个<code>length0</code>，可以求出空表的长度。<br>那么下面这个函数有什么作用呢？</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">length0</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><p>由于<code>(length0 (rest lst))</code>是可以正确计算的，所以上面这个函数，可以计算长度小于等于1的list的长度。<br>你可能会问，但是我们没有<code>length0</code>这个名字呀？<br>没关系，我们将<code>length0</code>代换成上一小结的匿名函数形式，如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                   <span class="number">0</span></span><br><span class="line">                   (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br><span class="line">             (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><p>那么这个函数，我们就可以把它叫作<code>length1</code>了，因为它可以正确求出长度小于等于1的list的长度！<br>那么，<code>length2</code>就再来一次啦，把<code>length1</code>丢进那个定义，也不需要显式使用<code>length2</code>啦！</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length2</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                   <span class="number">0</span></span><br><span class="line">                   (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">                            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                                <span class="number">0</span></span><br><span class="line">                                (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br><span class="line">                          (<span class="name">rest</span> lst)))))</span><br><span class="line">             (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><p>试一试<code>length2</code>！</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ((lambda (lst)</span><br><span class="line">   (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">       <span class="number">0</span></span><br><span class="line">       (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">                (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                    <span class="number">0</span></span><br><span class="line">                    (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">                             (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                                 <span class="number">0</span></span><br><span class="line">                                 (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br><span class="line">                           (<span class="name">rest</span> lst)))))</span><br><span class="line">              (rest lst)))))</span><br><span class="line"> `(two apple))</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>真棒！现在能解决长度小于等于2的list了！<br>依此类推，我们能定义出<code>length3</code>、<code>length4</code>、<code>length5</code>,甚至<code>length100</code>、<code>length1000</code>、<code>length10000</code>了！<br>那么如果我们能写出<code>length∞</code>，不就得到了我们的原始<code>length</code>函数了吗，因为<code>length</code>是可以处理任意长度的list的函数！<br>但是，我们没办法写出<code>length∞</code>，因为无穷行代码哪里也放不下啊！（笑</p><h3 id="试着进行抽象">试着进行抽象</h3><p>试着观察<code>length0</code> <code>length1</code> <code>length2</code>，我们会发现，这三个函数都遵循相同的形式，只有<code>last-length</code>这个地方是需要改变的：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; same pattern</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><p>根据DRY原则，我们为什么不把相同的形式给抽象出来呢？<br>我们可以写出一个函数，接受一个参数<code>last-length</code>，然后就可以利用这个函数生成之后的<code>length[i]</code>了。<br>就像这样：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; abstract-length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><p>这个函数接受参数<code>last-length</code>,然后就会返回一个新的函数，可以比<code>last-length</code>多处理一个长度的list。<br>那么，<code>length0</code>可以表示为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">id</span>))</span><br></pre></td></tr></table></figure><p>那么同理，<code>length1</code>可以表示为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">length0</span>))</span><br></pre></td></tr></table></figure><p>当然，我们并没有<code>length0</code>,需要将其转换为匿名形式，也就是这样：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">id</span>)))</span><br></pre></td></tr></table></figure><p>那么<code>length2</code>？<br>容易，再来一次：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length2</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">id</span>))))</span><br></pre></td></tr></table></figure><p>**WAIT!!!**这难道不是依然在重复增加代码吗？<br>好吧，其实我们还是有所推进，别急，慢慢来。</p><h3 id="返回length函数的函数：make-length">返回length函数的函数：make-length</h3><p>按照我们刚刚的抽象，<code>abstract-length</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; abstract-length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><p>对于这个函数，我们如果：</p><ul><li>喂给它<code>id</code>,即<code>(abstract-length id)</code>，那么它会返回<code>length0</code></li><li>喂给它<code>length[i]</code>，即<code>(abstract-length length[i])</code>，那么它会返回<code>length[i+1]</code><br>既然这个函数能够返回我们需要的<code>length[i]</code>,不妨将其称之为<code>make-length</code>函数。<br>那就可以写成函数应用的形式，就像我们对<code>last-length</code>的抽象：</li></ul><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> id))</span><br><span class="line"> abstract-length)</span><br></pre></td></tr></table></figure><p>依然运用我们的old trick，将<code>abstract-length</code>写成匿名形式：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> id))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>好了，虽然这个形式看上去很复杂，但是它就是我们熟悉的<code>length0</code>!<br>那么，<code>length1</code>呢？<br>很简单，我们只需要将<code>length0</code>喂给我们的<code>abstract-length</code>，就会得到<code>length1</code>。也就是将<code>length0</code>中的<code>id</code>替换成<code>length0</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> length0))</span><br><span class="line"> abstract-length)</span><br></pre></td></tr></table></figure><p>换成匿名表达：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> (<span class="name">make-length</span> id)))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>再进一步，<code>length2</code>：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length2</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> (<span class="name">make-length</span> (<span class="name">make-length</span> id))))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>那，<code>length3</code>？</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length3</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> (<span class="name">make-length</span> (<span class="name">make-length</span> (<span class="name">make-length</span> id)))))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>好了好了，就不再继续演示了。<br>那么回顾一下我们的新表示方法，好像它们之间的差别，仅仅在于对参数<code>id</code>应用了多少次<code>make-length</code>函数：</p><ul><li><code>length0</code>: (make-length id)</li><li><code>length1</code>: (make-length (make-length id))</li><li><code>length2</code>: (make-length (make-length (make-length id)))</li><li><code>length3</code>: (make-length (make-length (make-length (make-length id))))</li></ul><p>是不是有点类似汉诺塔？</p><h3 id="快到终点了">快到终点了</h3><p>事实上，每当我们使用<code>length</code>函数，我们并不会给它一个无限长的list。<br>那么，只要我们用一个足够大的<code>length[i]</code>，可不可行呢？按照我们上一小节的抽象，我们可以轻易地写出<code>length100</code>，甚至<code>length10000000000000000</code>。<br>问题在于，这个足够大的数，仍然可能不够大。</p><p>那么什么时候我们会知道，这个数不够大呢？<br>显然，当我们需要用到最最最最内层的函数<code>id</code>，也就是计算<code>(id (rest lst))</code>的时候，就代表，这个数不够大了。</p><p>**注意：**我们喂给<code>length2</code>一个长度小于等于2的list时，<code>id</code>的函数应用是没有求值的。</p><p>那么，如果每当我们需要对<code>id</code>的函数应用求值的时候，我们再对其应用一次<code>make-length</code>，不就可以避免对<code>id</code>的函数应用求值了吗？</p><p>那么，如果我们从不对<code>id</code>的函数应用求值，也就是说，<code>id</code>根本没什么用，我们可以把<strong>任意函数</strong>传递给最内层的<code>make-length</code>。</p><p>那么，为何不试一试把<code>make-length</code>作为最内层的参数传给<code>make-length</code>呢。<br>那么，<code>length0</code>:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>回过头来看，其实<code>last-length</code>也是接受一个参数<code>length[i]</code>，然后返回新的函数<code>length[i+1]</code>。</p><p>那不是和<code>make-length</code>一样了？<br>是这样。<br>那我们将<code>last-length</code>改名为<code>make-length</code>也可以吗？<br>可以。只要保持函数参数和函数体内的名字一致即可。<br>那我们改名吧：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">make-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>进一步，依照刚刚所说，我们只需要将<code>length1</code>中最内层的函数应用添加一层</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name">make-length</span> id) (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>等等？为什么<code>id</code>又出现了？<br>因为我们只能处理长度小于等于1的list。<br>如何解决此困境？<br>再次将<code>make-length</code>传递给自身，这样每当我们需要更长的<code>length[i]</code>的时候，就会自动将函数的处理能力+1。<br>就像这样：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name">make-length</span> make-length) (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>这个函数的工作机理是，它展开的层数总是和喂给它的<code>list</code>长度一样多。因为一旦层数不够长，他就会将<code>make-length</code>应用于自身，增加多一次的处理。</p><p>试一试<code>length1</code>能否工作:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; (((lambda (make-length)</span><br><span class="line">    (make-length make-length))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (add1 ((make-length make-length) (rest lst)))))))</span><br><span class="line"> `(apple))</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> &gt; (((lambda (make-length)</span><br><span class="line">    (make-length make-length))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (add1 ((make-length make-length) (rest lst)))))))</span><br><span class="line"> `(two apple))</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>很好，我们得到了一个能工作的<code>length1</code>，事实上，这已经不再是<code>length1</code>了，因为它能处理长度为2的list！甚至更长的！<br>这就和我们最初的<code>length</code>一样了！</p><p>（如果你不明白这里的<code>length1</code>为何能工作，可以试着再读一读这两个小节，或者手动推演一下这个lambda式子）</p><h3 id="不止应用于length">不止应用于length</h3><p>对比一下我们的显式递归<code>length</code>和<code>newlength</code>:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name">make-length</span> make-length) (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>这两个定义在形式上还是有差别，因为前者定义中的<code>(length (rest lst))</code>，在后者定义中变成了<code>((make-length make-length) (rest lst))</code>。</p><p>为了使它们表现的一致，我们将<code>(make-length make-length)</code>抽象出来就好了，然后作为参数传进去，而且我们将参数取名为<code>length</code>！</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">    <span class="comment">;;;;;;;</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">       (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">           <span class="number">0</span></span><br><span class="line">           (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    <span class="comment">;;;;;;;</span></span><br><span class="line">   (<span class="name">make-length</span> make-length))))</span><br></pre></td></tr></table></figure><p>好了，看上去大功告成，可以把两个定义在形式上相同的地方抽象出来，这样就可以用在别的递归函数定义中了。</p><p>WAIT！还没完，我们试着用一用<code>newlength</code>，试着对<code>(apple)</code>求值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; (((lambda (make-length)</span><br><span class="line">    (make-length make-length))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">     (make-length make-length))))</span><br><span class="line"> `(apple))</span><br></pre></td></tr></table></figure><p>我们需要将这个表达式的值求出来，然后应用到<code>(apple)</code>上</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> <span class="comment">; A-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    (<span class="name">make-length</span> make-length)))</span><br><span class="line"> <span class="comment">; A-end</span></span><br><span class="line"> )</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>首先我们需要将<code>(lambda (make-length) (make-length make-length))</code>应用于后面那个式子(记作A)上，得到<code>(A A)</code>，即：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> <span class="comment">; B-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    (<span class="name">make-length</span> make-length)))</span><br><span class="line"> <span class="comment">; B-end</span></span><br><span class="line"> <span class="comment">; C-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    (<span class="name">make-length</span> make-length)))</span><br><span class="line"> <span class="comment">; C-end</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>然后继续求值，将B应用于C，也就是将B的参数<code>make-length</code>用C进行代换，得到：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(</span><br><span class="line"> <span class="comment">; D-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> <span class="comment">; D-end</span></span><br><span class="line"> <span class="comment">; E-start</span></span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">     (<span class="name">make-length</span> make-length)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">     (<span class="name">make-length</span> make-length))))</span><br><span class="line"> <span class="comment">; E-end</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们得到了形如<code>(D E)</code>的式子，然后我们继续求值，你会注意到，E的形状和刚刚我们得到的<code>(A A)</code>形状是一样的，所以我们会在这里一直循环下去。</p><p>这就很奇怪了，我们在把<code>(make-length make-length)</code>抽象出来之前函数都是好的呀？</p><p>回想一下，<code>make-length</code>的作用是生成一个新的<code>length[i+1]</code>函数，然后将其应用于一个list。<br>但是我们把<code>(make-length make-length)</code>抽象出来之后，我们无法得到这个<code>length[i+1]</code>函数，因为Scheme是应用序求值策略，<code>make-length</code>反复对自身进行应用。<br>因此，我们要想一个办法，先让<code>make-length</code>的应用停一停，等到需要它对自身进行应用的时候，再继续。<br>这个方法并不复杂，就是将<code>(make-length make-length)</code>包裹在一个<code>lambda</code>表达式之中，即<code>(lambda (x) ((make-length make-length) x))</code>。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (x) ((<span class="name">make-length</span> make-length) x))</span><br><span class="line">                (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><p>然后我们再把它抽象出来。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; new newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (</span><br><span class="line">    <span class="comment">;;;;;;</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    <span class="comment">;;;;;;</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x) ((<span class="name">make-length</span> make-length) x)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><p>这样，我们就得能正确使用的<code>newlength</code>了，就能继续我们的抽象工作了。</p><p>对比一下<code>newlength</code>和原始<code>length</code>，使用“;;;;;;”分隔开的部分，完全就是原始<code>length</code>的定义，除了将原始<code>length</code>定义中的<code>define</code>替换成<code>lambda</code>。而且这部分，和<code>make-length</code>完全无关！</p><p>那么，我们将这部分抽象出来，使其变成一个函数应用。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> <span class="comment">; Y-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (a-func)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">      (<span class="name">make-length</span> make-length))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">      (<span class="name">a-func</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                ((<span class="name">make-length</span> make-length) x))))))</span><br><span class="line"> <span class="comment">; Y-end</span></span><br><span class="line"> <span class="comment">; F-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> <span class="comment">; F-end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>现在我们有了两部分，Y和F：</p><ul><li>Y部分是一个函数，它接受一个和原始<code>length</code>具有相同形式的函数，然后返回一个递归函数<code>length</code>；</li><li>F部分，就是和原始<code>length</code>形式相同的匿名函数啦。</li></ul><p>那么这个Y部分，就是我们的Y combinator！一般被称作应用序Y combinator。<br>化简一下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; applicative-order Y combinator</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (func)</span><br><span class="line">  ((<span class="name"><span class="builtin-name">lambda</span></span> (f)</span><br><span class="line">     (<span class="name">f</span> f))</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (f)</span><br><span class="line">     (<span class="name">func</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">             ((<span class="name">f</span> f) x))))))</span><br></pre></td></tr></table></figure><p>有了Y combinator，我们就能从匿名函数中定义递归函数了！</p><h3 id="练习">练习</h3><p>你能写出一个简单的阶乘函数<code>factorial</code>，然后用Y combinator将其变成匿名递归函数吗？</p><h3 id="参考">参考</h3><ol><li><a href="https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992" target="_blank" rel="noopener"><em>The Little Schemer</em></a></li><li><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="noopener">Fixed-point combinator - Wikipidia</a></li><li><a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/node85.html" target="_blank" rel="noopener">Normal Order and Applicative Order - <em>SICP</em></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;在Lambda演算中，函数是没有名字的（都是匿名函数），那么如果函数没有名字，也就无法在函数体内显式地调用自身，也就无法定义递归函数，Y combinator就是用来解决这个问题的。&lt;br&gt;
这篇文章想抛开那些数学概念，用程序语言（Scheme）的形式来讲解我们是如何推导出Y combinator的。&lt;/p&gt;
&lt;p&gt;运行环境：&lt;br&gt;
IDE：&lt;a href=&quot;https://racket-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DrRacket&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Scheme" scheme="http://duanyifu.com/tags/Scheme/"/>
    
      <category term="Y combinator" scheme="http://duanyifu.com/tags/Y-combinator/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter10 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/09/13/PIHex10/"/>
    <id>http://duanyifu.com/2016/09/13/PIHex10/</id>
    <published>2016-09-13T13:11:45.000Z</published>
    <updated>2016-09-13T19:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><p>第九章的习题暂时跳过了，先更第十章。<br>开学了，事情多了起来，还要找工作，加把劲最近把这本书刷完吧！:P</p><p>其实从第8章开始，这本书对于monad就讲的太少，过几天这本书要出第二版，希望能在这方面改进改进。。。<br>我下单了一本《Haskell趣学指南》，打算结合起来看，然后再补上跳过的习题。</p><hr><h4 id="定义函数-mult-nat-nat-nat">定义函数 mult :: Nat -&gt; Nat -&gt; Nat</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Zero</span> | <span class="type">Succ</span> <span class="type">Nat</span></span></span><br><span class="line"><span class="title">nat2int</span> :: <span class="type">Nat</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">nat2int</span> <span class="type">Zero</span> = <span class="number">0</span></span><br><span class="line"><span class="title">nat2int</span> (<span class="type">Succ</span> n) = <span class="number">1</span> + nat2int n</span><br><span class="line"></span><br><span class="line"><span class="title">int2nat</span> :: <span class="type">Int</span> -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">int2nat</span> <span class="number">0</span> = <span class="type">Zero</span></span><br><span class="line"><span class="title">int2nat</span> n = <span class="type">Succ</span> (int2nat (n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">add</span> <span class="type">Zero</span> n = n</span><br><span class="line"><span class="title">add</span> (<span class="type">Succ</span> m) n = <span class="type">Succ</span> (add m n)</span><br><span class="line"></span><br><span class="line"><span class="title">mult</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">mult</span> <span class="type">Zero</span> _ = <span class="type">Zero</span></span><br><span class="line"><span class="title">mult</span> (<span class="type">Succ</span> m) n = add (mult m n) n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 2) (int2nat 3))</span></span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 0) (int2nat 3))</span></span><br><span class="line"><span class="comment">-- 0</span></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 1) (int2nat 3))</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 10) (int2nat 13))</span></span><br><span class="line"><span class="comment">-- 130</span></span><br></pre></td></tr></table></figure><h4 id="重新定义occurs-int-tree-bool">重新定义<code>occurs :: Int -&gt; Tree -&gt; Bool</code></h4><p>需要使用标准库<code>data Ordering = LT | EQ | GT</code>, 以及<br><code>compare :: Ord =&gt; a -&gt; a -&gt; Ordering</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> = <span class="type">Leaf</span> <span class="type">Int</span> | <span class="type">Node</span> <span class="type">Tree</span> <span class="type">Int</span> <span class="type">Tree</span></span></span><br><span class="line"><span class="title">tr</span> :: <span class="type">Tree</span></span><br><span class="line"><span class="title">tr</span> = <span class="type">Node</span> (<span class="type">Node</span> (<span class="type">Leaf</span> <span class="number">1</span>) <span class="number">3</span> (<span class="type">Leaf</span> <span class="number">4</span>)) <span class="number">5</span> (<span class="type">Node</span> (<span class="type">Leaf</span> <span class="number">6</span>) <span class="number">7</span> (<span class="type">Leaf</span> <span class="number">9</span>))</span><br><span class="line"><span class="title">occurs</span> :: <span class="type">Int</span> -&gt; <span class="type">Tree</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">occurs</span> m (<span class="type">Leaf</span> n) = m == n</span><br><span class="line"><span class="title">occurs</span> m (<span class="type">Node</span> l n r) = <span class="keyword">case</span> compare m n <span class="keyword">of</span></span><br><span class="line">                            <span class="type">LT</span> -&gt; occurs m l</span><br><span class="line">                            <span class="type">EQ</span> -&gt; <span class="type">True</span></span><br><span class="line">                            <span class="type">GT</span> -&gt; occurs m r</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="判断平衡树balanced-tree-bool">判断平衡树<code>balanced :: Tree -&gt; Bool</code></h4><p>平衡树：左、右子树的叶子数量相差不超过一个</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree1</span> = <span class="type">Leaf1</span> <span class="type">Int</span> | <span class="type">Node1</span> <span class="type">Tree1</span> <span class="type">Tree1</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">t1</span> :: <span class="type">Tree1</span></span><br><span class="line"><span class="title">t1</span> = <span class="type">Node1</span> (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Leaf1</span> <span class="number">4</span>)) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">6</span>) (<span class="type">Leaf1</span> <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">t2</span> :: <span class="type">Tree1</span></span><br><span class="line"><span class="title">t2</span> = <span class="type">Node1</span> (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Leaf1</span> <span class="number">4</span>))) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">6</span>) (<span class="type">Leaf1</span> <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">t3</span> :: <span class="type">Tree1</span></span><br><span class="line"><span class="title">t3</span> = <span class="type">Node1</span> (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Leaf1</span> <span class="number">4</span>))) (<span class="type">Leaf1</span> <span class="number">6</span>)</span><br><span class="line"><span class="title">leafs</span> :: <span class="type">Tree1</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">leafs</span> (<span class="type">Leaf1</span> _) = <span class="number">1</span></span><br><span class="line"><span class="title">leafs</span> (<span class="type">Node1</span> l r) = leafs l + leafs r</span><br><span class="line"></span><br><span class="line"><span class="title">balanced</span> :: <span class="type">Tree1</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">balanced</span> (<span class="type">Leaf1</span> _) = <span class="type">True</span></span><br><span class="line"><span class="title">balanced</span> (<span class="type">Node1</span> l r) = abs (leafs l - leafs r) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; balanced t1</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; balanced t2</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; balanced t3</span></span><br><span class="line"><span class="comment">-- False</span></span><br></pre></td></tr></table></figure><h4 id="根据list生成一个平衡树">根据list生成一个平衡树</h4><p>思路也蛮简单，把list分成两半，然后递归就成了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">balance</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Tree1</span></span><br><span class="line"><span class="title">balance</span> xs</span><br><span class="line">    | null xs = error <span class="string">""</span></span><br><span class="line">    | length xs == <span class="number">1</span> = <span class="type">Leaf1</span> (head xs)</span><br><span class="line">    | otherwise = <span class="type">Node1</span> (balance x) (balance y)</span><br><span class="line">                    <span class="keyword">where</span> n = length xs `div` <span class="number">2</span></span><br><span class="line">                          x = take n xs</span><br><span class="line">                          y = drop n xs</span><br><span class="line"></span><br><span class="line"><span class="title">flatten</span> :: <span class="type">Tree1</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">flatten</span> (<span class="type">Leaf1</span> n) = [n]</span><br><span class="line"><span class="title">flatten</span> (<span class="type">Node1</span> l r) = flatten l ++ flatten r</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; flatten (balance [])</span></span><br><span class="line"><span class="comment">-- *** Exception:</span></span><br><span class="line"><span class="comment">-- CallStack (from HasCallStack):</span></span><br><span class="line"><span class="comment">--   error, called at ch10ex.hs:71:24 in main:Main</span></span><br><span class="line"><span class="comment">-- *Main&gt; flatten (balance [1])</span></span><br><span class="line"><span class="comment">-- [1]</span></span><br><span class="line"><span class="comment">-- *Main&gt; flatten (balance [1,2,3,4])</span></span><br><span class="line"><span class="comment">-- [1,2,3,4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改tautology-checker使之支持-disjunction-和-equivalence-运算符">修改Tautology checker使之支持<code>\/</code>(disjunction)和<code>&lt;=&gt;</code>(equivalence)运算符</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Assoc</span> k v = [(<span class="title">k</span>, <span class="title">v</span>)]</span></span><br><span class="line"><span class="title">find</span> :: <span class="type">Eq</span> k =&gt; k -&gt; <span class="type">Assoc</span> k v -&gt; v</span><br><span class="line"><span class="title">find</span> k t = head [v | (k', v) &lt;- t, k == k']</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Prop</span> = <span class="type">Const</span> <span class="type">Bool</span></span></span><br><span class="line">          | <span class="type">Var</span> <span class="type">Char</span></span><br><span class="line">          | <span class="type">Not</span> <span class="type">Prop</span></span><br><span class="line">          | <span class="type">And</span> <span class="type">Prop</span> <span class="type">Prop</span></span><br><span class="line">          | <span class="type">Disj</span> <span class="type">Prop</span> <span class="type">Prop</span> <span class="comment">-- disjunction</span></span><br><span class="line">          | <span class="type">Equi</span> <span class="type">Prop</span> <span class="type">Prop</span> <span class="comment">-- equivalence</span></span><br><span class="line">          | <span class="type">Imply</span> <span class="type">Prop</span> <span class="type">Prop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Subst</span> = <span class="type">Assoc</span> <span class="type">Char</span> <span class="type">Bool</span></span></span><br><span class="line"><span class="comment">-- [('A', True), ('B', False)]</span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Subst</span> -&gt; <span class="type">Prop</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">eval</span> _ (<span class="type">Const</span> b) = b</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Var</span> x) = find x s</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Not</span> p) = not (eval s p)</span><br><span class="line"><span class="title">eval</span> s (<span class="type">And</span> p q) = eval s p &amp;&amp; eval s q</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Disj</span> p q) = eval s p || eval s q</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Equi</span> p q) = eval s p == eval s q</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Imply</span> p q) = eval s p &lt;= eval s q</span><br><span class="line"></span><br><span class="line"><span class="title">vars</span> :: <span class="type">Prop</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">vars</span> (<span class="type">Const</span> _) = []</span><br><span class="line"><span class="title">vars</span> (<span class="type">Var</span> x) = [x]</span><br><span class="line"><span class="title">vars</span> (<span class="type">Not</span> p) = vars p</span><br><span class="line"><span class="title">vars</span> (<span class="type">And</span> p q) = vars p ++ vars q</span><br><span class="line"><span class="title">vars</span> (<span class="type">Disj</span> p q) = vars p ++ vars q</span><br><span class="line"><span class="title">vars</span> (<span class="type">Equi</span> p q) = vars p ++ vars q</span><br><span class="line"><span class="title">vars</span> (<span class="type">Imply</span> p q) = vars p ++ vars q</span><br><span class="line"></span><br><span class="line"><span class="title">bools</span> :: <span class="type">Int</span> -&gt; [[<span class="type">Bool</span>]]</span><br><span class="line"><span class="title">bools</span> <span class="number">0</span> = [[]]</span><br><span class="line"><span class="title">bools</span> n = map (<span class="type">False</span>:) bss ++ map (<span class="type">True</span>:) bss</span><br><span class="line">                    <span class="keyword">where</span> bss = bools (n - <span class="number">1</span>)</span><br><span class="line"><span class="title">rmdups</span> :: <span class="type">Eq</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">rmdups</span> [] = []</span><br><span class="line"><span class="title">rmdups</span> (x : xs) = x : rmdups (filter (/= x) xs)</span><br><span class="line"></span><br><span class="line"><span class="title">substs</span> :: <span class="type">Prop</span> -&gt; [<span class="type">Subst</span>]</span><br><span class="line"><span class="title">substs</span> p = map (zip us) (bools (length us))</span><br><span class="line">            <span class="keyword">where</span> us = rmdups (vars p)</span><br><span class="line"><span class="title">isTaut</span> :: <span class="type">Prop</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isTaut</span> p = and [eval s p | s &lt;- substs p]</span><br><span class="line"></span><br><span class="line"><span class="title">p1</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p1</span> = <span class="type">Equi</span> (<span class="type">Var</span> '<span class="type">A'</span>) (<span class="type">Not</span> (<span class="type">Var</span> '<span class="type">A'</span>))</span><br><span class="line"><span class="title">p2</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p2</span> = <span class="type">Equi</span> (<span class="type">Var</span> '<span class="type">A'</span>) (<span class="type">Var</span> '<span class="type">A'</span>)</span><br><span class="line"><span class="title">p3</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p3</span> = <span class="type">Equi</span> (<span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Var</span> '<span class="type">B'</span>)) (<span class="type">Var</span> '<span class="type">A'</span>)) (<span class="type">Disj</span> (<span class="type">Var</span> '<span class="type">A'</span>) (<span class="type">Var</span> '<span class="type">B'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- p4 : (!(!(!P \/ Q) \/ P) \/ P)</span></span><br><span class="line"><span class="title">p4</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p4</span> = <span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Var</span> '<span class="type">A'</span>)) (<span class="type">Var</span> '<span class="type">B'</span>))) (<span class="type">Var</span> '<span class="type">A'</span>))) (<span class="type">Var</span> '<span class="type">A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p1</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p2</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p3</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p4</span></span><br><span class="line"><span class="comment">-- True</span></span><br></pre></td></tr></table></figure><h4 id="扩展abstract-machine使之支持乘法">扩展Abstract machine使之支持乘法</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 7 abstract machine</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> = <span class="type">Val</span> <span class="type">Int</span> | <span class="type">Add</span> <span class="type">Expr</span> <span class="type">Expr</span> | <span class="type">Mul</span> <span class="type">Expr</span> <span class="type">Expr</span></span></span><br><span class="line"><span class="comment">-- value :: Expr -&gt; Int</span></span><br><span class="line"><span class="comment">-- value (Val n) = n</span></span><br><span class="line"><span class="comment">-- value (Add x y) = value x + value y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Cont</span> = [<span class="type">Op</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Op</span> = <span class="type">EVALADD</span> <span class="type">Expr</span> | <span class="type">EVALMUL</span> <span class="type">Expr</span> | <span class="type">ADD</span> <span class="type">Int</span> | <span class="type">MUL</span> <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Cont</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Val</span> n) c = exec c n</span><br><span class="line"><span class="title">eval</span> (<span class="type">Add</span> x y) c = eval x (<span class="type">EVALADD</span> y : c)</span><br><span class="line"><span class="title">eval</span> (<span class="type">Mul</span> x y) c = eval x (<span class="type">EVALMUL</span> y : c)</span><br><span class="line"></span><br><span class="line"><span class="title">exec</span> :: <span class="type">Cont</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">exec</span> [] n = n</span><br><span class="line"><span class="title">exec</span> (<span class="type">EVALADD</span> y : c) n = eval y (<span class="type">ADD</span> n : c)</span><br><span class="line"><span class="title">exec</span> (<span class="type">EVALMUL</span> y : c) n = eval y (<span class="type">MUL</span> n : c)</span><br><span class="line"><span class="title">exec</span> (<span class="type">ADD</span> n : c) m = exec c (n + m)</span><br><span class="line"><span class="title">exec</span> (<span class="type">MUL</span> n : c) m = exec c (n * m)</span><br><span class="line"></span><br><span class="line"><span class="title">value</span> :: <span class="type">Expr</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">value</span> e = eval e []</span><br><span class="line"></span><br><span class="line"><span class="title">p1</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">p1</span> = <span class="type">Add</span> (<span class="type">Mul</span> (<span class="type">Val</span> <span class="number">3</span>) (<span class="type">Val</span> <span class="number">2</span>)) (<span class="type">Val</span> <span class="number">5</span>) <span class="comment">-- 3 * 2 + 5</span></span><br><span class="line"></span><br><span class="line"><span class="title">p2</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">p2</span> = <span class="type">Add</span> (<span class="type">Mul</span> (<span class="type">Val</span> <span class="number">3</span>) (<span class="type">Add</span> (<span class="type">Val</span> <span class="number">3</span>) (<span class="type">Val</span> <span class="number">2</span>))) (<span class="type">Val</span> <span class="number">1</span>) <span class="comment">-- 3 * (3 + 2) + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; value p2</span></span><br><span class="line"><span class="comment">-- 16</span></span><br><span class="line"><span class="comment">-- *Main&gt; value p1</span></span><br><span class="line"><span class="comment">-- 11</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第九章的习题暂时跳过了，先更第十章。&lt;br&gt;
开学了，事情多了起来，还要找工作，加把劲最近把这本书刷完吧！:P&lt;/p&gt;
&lt;p&gt;其实从第8章开始，这本书对于monad就讲的太少，过几天这本书要出第二版，希望能在这方面改进改进。。。&lt;br&gt;
我下单了一本《Haskell趣学指南》，打算结合起来看，然后再补上跳过的习题。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;定义函数-mult-nat-nat-nat&quot;&gt;定义函数 mult :: Nat -&amp;gt; Nat -&amp;gt; Nat&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; | &lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;nat2int&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;nat2int&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;nat2int&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; n) = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + nat2int n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int2nat&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int2nat&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int2nat&lt;/span&gt; n = &lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; (int2nat (n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; n = n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; m) n = &lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; (add m n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mult&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mult&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; _ = &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mult&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; m) n = add (mult m n) n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 2) (int2nat 3))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 0) (int2nat 3))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 1) (int2nat 3))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 10) (int2nat 13))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 130&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;重新定义occurs-int-tree-bool&quot;&gt;重新定义&lt;code&gt;occurs :: Int -&amp;gt; Tree -&amp;gt; Bool&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;需要使用标准库&lt;code&gt;data Ordering = LT | EQ | GT&lt;/code&gt;, 以及&lt;br&gt;
&lt;code&gt;compare :: Ord =&amp;gt; a -&amp;gt; a -&amp;gt; Ordering&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; | &lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;occurs&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;occurs&lt;/span&gt; m (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; n) = m == n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;occurs&lt;/span&gt; m (&lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; l n r) = &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; compare m n &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;type&quot;&gt;LT&lt;/span&gt; -&amp;gt; occurs m l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;type&quot;&gt;EQ&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;type&quot;&gt;GT&lt;/span&gt; -&amp;gt; occurs m r&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter8 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/09/08/PIHex8/"/>
    <id>http://duanyifu.com/2016/09/08/PIHex8/</id>
    <published>2016-09-08T13:24:24.000Z</published>
    <updated>2016-09-13T19:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><p>这章信息量简直爆炸，书上给的东西太少了，讲的又太多了。找了一堆资料看了好久才弄明白。</p><p>结合的参考资料如下：<br><a href="http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13" target="_blank" rel="noopener">Chapter8讲课视频</a><br><a href="http://www.cs.uwyo.edu/~jlc/courses/3015/parser_pearl.pdf" target="_blank" rel="noopener">Monadic Parsing in Haskell</a><br><a href="http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function" target="_blank" rel="noopener">“Programming In Haskell” error in sat function</a></p><p>按照书上的<code>Parser</code>定义，是没法使用do notation的，所以下面的习题全部用<code>&gt;&gt;=</code>完成。</p><p>完整的代码我放在<a href="https://gist.github.com/mistwave/b48c517e18436f6ac8fe350de929ee6a" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="int-parser-int"><code>int :: Parser Int</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">int</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">int</span> = natural +++</span><br><span class="line">      (symbol <span class="string">"-"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">       natural &gt;&gt;= \x -&gt;</span><br><span class="line">       return (-x))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; parse int "123da"</span></span><br><span class="line"><span class="comment">-- [(123,"da")]</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse int "sdada"</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse int "-213sdada"</span></span><br><span class="line"><span class="comment">-- [(-213,"sdada")]</span></span><br></pre></td></tr></table></figure><h4 id="comment-parser"><code>comment :: Parser ()</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">comment</span> :: <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">comment</span> = symbol <span class="string">"--"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">          many (sat (/= '\n')) &gt;&gt;= \_ -&gt;</span><br><span class="line">          many (char '\n') &gt;&gt;= \_ -&gt;</span><br><span class="line">          return ()  <span class="comment">-- why return ()?</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse comment "foo"</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse comment "--foo"</span></span><br><span class="line"><span class="comment">-- [((),"")]</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse comment "--foo\nbar"</span></span><br><span class="line"><span class="comment">-- [((),"bar")]</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="扩展arithmetic-expressions-parser">扩展arithmetic expressions parser</h4><p>这里一个坑就是在于处理<code>8 / 2 / 2 / 2</code>，<code>1 - 2 - 3 - 4</code>这种情况，如果模仿<code>+</code>, <code>*</code>，的实现，很错误地容易把<code>8 / 2 / 2 / 2</code>parse成<code>(8 / 2) / (2 / 2)</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- new gramma rules:</span></span><br><span class="line"><span class="comment">-- expr   ::= term (+ expr | - expr | &lt;E&gt;)</span></span><br><span class="line"><span class="comment">-- term   ::= power (* term | / term | &lt;E&gt;)</span></span><br><span class="line"><span class="comment">-- power  ::= factor (^ power | &lt;E&gt;)</span></span><br><span class="line"><span class="comment">-- factor ::= (expr) | nat</span></span><br><span class="line"><span class="comment">-- nat    ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- !! WRONG:</span></span><br><span class="line"><span class="comment">-- (symbol "-" &gt;&gt;= \_ -&gt;</span></span><br><span class="line"><span class="comment">--  expr &gt;&gt;= \e -&gt;</span></span><br><span class="line"><span class="comment">--  return (ex - e))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (symbol "/" &gt;&gt;= \_ -&gt;</span></span><br><span class="line"><span class="comment">--  term &gt;&gt;= \t -&gt;</span></span><br><span class="line"><span class="comment">--  return (f `div` t))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">expr</span> = term &gt;&gt;= \t -&gt;</span><br><span class="line">       (symbol <span class="string">"+"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">        expr       &gt;&gt;= \e -&gt;</span><br><span class="line">        return (t + e))</span><br><span class="line">       +++</span><br><span class="line">       (many (symbol <span class="string">"-"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">              term       &gt;&gt;= \n -&gt;</span><br><span class="line">              return n)  &gt;&gt;= \ss -&gt;</span><br><span class="line">        return (foldl (-) t ss))</span><br><span class="line">       +++</span><br><span class="line">       return t</span><br><span class="line"></span><br><span class="line"><span class="title">term</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">term</span> = power &gt;&gt;= \p -&gt;</span><br><span class="line">       (symbol <span class="string">"*"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">        term       &gt;&gt;= \t -&gt;</span><br><span class="line">        return (p * t))</span><br><span class="line">       +++</span><br><span class="line">       (many (symbol <span class="string">"/"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">              power      &gt;&gt;= \t -&gt;</span><br><span class="line">              return t)  &gt;&gt;= \ss -&gt;</span><br><span class="line">        return (foldl div p ss))</span><br><span class="line">       +++</span><br><span class="line">       return p</span><br><span class="line"></span><br><span class="line"><span class="title">power</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">power</span> = factor &gt;&gt;= \f -&gt;</span><br><span class="line">        (symbol <span class="string">"^"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">         power      &gt;&gt;= \p -&gt;</span><br><span class="line">         return (f ^ p))</span><br><span class="line">        +++ return f</span><br><span class="line"></span><br><span class="line"><span class="title">factor</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">factor</span> = (symbol <span class="string">"("</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">          expr       &gt;&gt;= \e -&gt;</span><br><span class="line">          symbol <span class="string">")"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">          return e)</span><br><span class="line">         +++ natural</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> xs = <span class="keyword">case</span> parse expr xs <span class="keyword">of</span></span><br><span class="line">            [(n, [])] -&gt; n</span><br><span class="line">            [(_, out)] -&gt; error(<span class="string">"unused input "</span> ++ out)</span><br><span class="line">            [] -&gt; error <span class="string">"invalid input"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2^3"</span></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2*3 ^ 4"</span></span><br><span class="line"><span class="comment">-- 1296</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2 ^ 3 * 4"</span></span><br><span class="line"><span class="comment">-- 4096</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2 + 2^ 2"</span></span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2^2^2"</span></span><br><span class="line"><span class="comment">-- 16</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "8-2-2-2"</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "16 /2/2/2"</span></span><br><span class="line"><span class="comment">-- 2</span></span><br></pre></td></tr></table></figure><h4 id="考虑expr-expr-nat-nat的parser">考虑<code>expr ::= expr - nat | nat</code>的parser</h4><p>要注意的点在和上一题是一样的.</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- expr'  ::= expr' - nat | nat</span></span><br><span class="line"><span class="comment">-- nat    ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"></span><br><span class="line"><span class="title">expr'</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">expr'</span> = natural &gt;&gt;= \n -&gt;</span><br><span class="line">        many (symbol <span class="string">"-"</span> &gt;&gt;= \_ -&gt; natural) &gt;&gt;= \ns -&gt;</span><br><span class="line">        return (foldl (-) n ns)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这章信息量简直爆炸，书上给的东西太少了，讲的又太多了。找了一堆资料看了好久才弄明白。&lt;/p&gt;
&lt;p&gt;结合的参考资料如下：&lt;br&gt;
&lt;a href=&quot;http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chapter8讲课视频&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://www.cs.uwyo.edu/~jlc/courses/3015/parser_pearl.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Monadic Parsing in Haskell&lt;/a&gt;&lt;br&gt;
&lt;a href=&quot;http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“Programming In Haskell” error in sat function&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照书上的&lt;code&gt;Parser&lt;/code&gt;定义，是没法使用do notation的，所以下面的习题全部用&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;完成。&lt;/p&gt;
&lt;p&gt;完整的代码我放在&lt;a href=&quot;https://gist.github.com/mistwave/b48c517e18436f6ac8fe350de929ee6a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;int-parser-int&quot;&gt;&lt;code&gt;int :: Parser Int&lt;/code&gt;&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; = natural +++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (symbol &lt;span class=&quot;string&quot;&gt;&quot;-&quot;&lt;/span&gt; &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       natural &amp;gt;&amp;gt;= \x -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       return (-x))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse int &quot;123da&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [(123,&quot;da&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse int &quot;sdada&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse int &quot;-213sdada&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [(-213,&quot;sdada&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;comment-parser&quot;&gt;&lt;code&gt;comment :: Parser ()&lt;/code&gt;&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;comment&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Parser&lt;/span&gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;comment&lt;/span&gt; = symbol &lt;span class=&quot;string&quot;&gt;&quot;--&quot;&lt;/span&gt; &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          many (sat (/= &#39;\n&#39;)) &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          many (char &#39;\n&#39;) &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return ()  &lt;span class=&quot;comment&quot;&gt;-- why return ()?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse comment &quot;foo&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse comment &quot;--foo&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [((),&quot;&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse comment &quot;--foo\nbar&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [((),&quot;bar&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter7 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/31/PIHex7/"/>
    <id>http://duanyifu.com/2016/08/31/PIHex7/</id>
    <published>2016-08-31T13:14:51.000Z</published>
    <updated>2016-09-04T13:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="用map和filter表示-f-x-x-xs-p-x">用<code>map</code>和<code>filter</code>表示<code>[f x | x &lt;- xs, p x]</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [f x | x &lt;- xs, p x]</span></span><br><span class="line"><span class="comment">-- [f x | x &lt;- xs, p x]</span></span><br><span class="line"><span class="comment">-- = map f (filter p xs)</span></span><br></pre></td></tr></table></figure><h4 id="定义高阶函数all-any-takewhile-dropwhile">定义高阶函数<code>all</code>, <code>any</code>, <code>takeWhile</code>, <code>dropWhile</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myall</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myall</span> _ [] = <span class="type">True</span></span><br><span class="line"><span class="title">myall</span> p (x : xs) | p x == <span class="type">False</span> = <span class="type">False</span></span><br><span class="line">                 | otherwise = myall p xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myall (&gt;3) [1..3]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myall (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myall (&gt;3) [4..5]</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"></span><br><span class="line"><span class="title">myany</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myany</span> _ [] = <span class="type">False</span></span><br><span class="line"><span class="title">myany</span> p (x : xs) | p x == <span class="type">True</span> = <span class="type">True</span></span><br><span class="line">                 | otherwise = myany p xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myany (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; myany (&gt;3) [1..3]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">mytakeWhile</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mytakeWhile</span> _ [] = []</span><br><span class="line"><span class="title">mytakeWhile</span> p (x : xs) | p x == <span class="type">True</span> = x : mytakeWhile p xs</span><br><span class="line">                       | otherwise = []</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mytakeWhile (&lt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytakeWhile (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytakeWhile (&lt;3) [1,2,3,1,2]</span></span><br><span class="line"><span class="comment">-- [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="title">mydropWhile</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mydropWhile</span> _ [] = []</span><br><span class="line"><span class="title">mydropWhile</span> p (x : xs) | p x == <span class="type">True</span> = mydropWhile p xs</span><br><span class="line">                       | otherwise = x : xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mydropWhile (&lt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- [3,4,5]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mydropWhile (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="用foldr定义map-f和filter-p">用<code>foldr</code>定义<code>map f</code>和<code>filter p</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mymap</span> f = foldr (\x xs -&gt; f x : xs) []</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mymap (*3) [1..6]</span></span><br><span class="line"><span class="comment">-- [3,6,9,12,15,18]</span></span><br><span class="line"><span class="title">myfilter</span> p = foldr (\x xs -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : xs <span class="keyword">else</span> xs) []</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用foldl定义dec2int-int-int">用<code>foldl</code>定义<code>dec2int :: [Int] -&gt; Int</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dec2int</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">dec2int</span> = foldl (\x y -&gt; x * <span class="number">10</span> + y) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; dec2int [2,3,4,5]</span></span><br><span class="line"><span class="comment">-- 2345</span></span><br><span class="line"><span class="comment">-- *Main&gt; dec2int [2]</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- *Main&gt; dec2int []</span></span><br><span class="line"><span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h4 id="修改错误：sumsqreven-compose-sum-map-2-filter-even">修改错误：<code>sumsqreven = compose [sum, map (^2), filter even]</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> = foldr (.) id</span><br><span class="line"></span><br><span class="line"><span class="title">sumsqreven</span> xs = sum (compose [map (^<span class="number">2</span>), filter even] xs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="curry-uncurry"><code>curry</code> &amp; <code>uncurry</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 6</span></span><br><span class="line"></span><br><span class="line"><span class="title">mycurry</span> :: ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)</span><br><span class="line"><span class="title">mycurry</span> f = \x y -&gt; f (x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">myuncurry</span> :: (a -&gt; b -&gt; c) -&gt; ((a, b) -&gt; c)</span><br><span class="line"><span class="title">myuncurry</span> f = \(x, y) -&gt; f x y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="利用unfold定义chop8-map-f-iterate-f">利用<code>unfold</code>定义<code>chop8</code>, <code>map f</code>, <code>iterate f</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unfold</span> p h t x | p x = []</span><br><span class="line">               | otherwise = h x : unfold p h t (t x)</span><br><span class="line"></span><br><span class="line"><span class="title">int2bin'</span> = unfold (== <span class="number">0</span>) (`mod` <span class="number">2</span>) (`div` <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">chop8'</span> :: [<span class="type">Int</span>] -&gt; [[<span class="type">Int</span>]]</span><br><span class="line"><span class="title">chop8'</span> = unfold (== []) (take <span class="number">8</span>) (drop <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">mymap'</span> f = unfold (== []) (f.head) tail</span><br><span class="line"></span><br><span class="line"><span class="title">myiterate</span> f = unfold (\_ -&gt; <span class="type">False</span>) id f</span><br></pre></td></tr></table></figure><h4 id="给string-transmitter程序加上奇偶校验位-parity-bit">给string transmitter程序加上奇偶校验位（parity bit）</h4><p>我这里是在数据位的末端添加的，奇数个1则为1，否则为0。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- import Data.Char</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Bit</span> = <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">bin2int</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">-- bin2int bits = sum [w * b | (w, b) &lt;- zip weights bits]</span></span><br><span class="line"><span class="comment">--                 where weights = iterate (*2) 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">bin2int</span> = foldr (\x y -&gt; x + <span class="number">2</span> * y) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">int2bin</span> :: <span class="type">Int</span> -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">int2bin</span> <span class="number">0</span> = []</span><br><span class="line"><span class="title">int2bin</span> n = n `mod` <span class="number">2</span> : int2bin (n `div` <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">make8</span> :: [<span class="type">Bit</span>] -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">make8</span> bits = take <span class="number">8</span> (bits ++ repeat <span class="number">0</span>)</span><br><span class="line"><span class="comment">--new</span></span><br><span class="line"><span class="title">count1</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">Bit</span></span><br><span class="line"><span class="title">count1</span> = (`mod` <span class="number">2</span>) . sum</span><br><span class="line"><span class="comment">--new</span></span><br><span class="line"><span class="title">addparitybits</span> :: [<span class="type">Bit</span>] -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">addparitybits</span> bits = bits ++ [count1 bits]</span><br><span class="line"><span class="comment">--modifyed</span></span><br><span class="line"><span class="title">encode</span> :: <span class="type">String</span> -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">encode</span> = concat.map (addparitybits.make8.int2bin.ord)</span><br><span class="line"></span><br><span class="line"><span class="title">chop9</span> :: [<span class="type">Bit</span>] -&gt; [[<span class="type">Bit</span>]]</span><br><span class="line"><span class="title">chop9</span> [] = []</span><br><span class="line"><span class="title">chop9</span> bits = take <span class="number">9</span> bits : chop9 (drop <span class="number">9</span> bits)</span><br><span class="line"></span><br><span class="line"><span class="comment">--new</span></span><br><span class="line"><span class="title">isvalid</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isvalid</span> bits = (count1 (take <span class="number">8</span> bits)) == (last bits)</span><br><span class="line"></span><br><span class="line"><span class="title">decode</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="title">decode</span> xs | all isvalid (chop9 xs) = map (chr.bin2int.(take <span class="number">8</span>)) (chop9 xs)</span><br><span class="line">          | otherwise = error <span class="string">"Wrong parity bit!"</span></span><br><span class="line"></span><br><span class="line"><span class="title">transmit</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">transmit</span> = decode.channel.encode</span><br><span class="line"></span><br><span class="line"><span class="title">channel</span> :: [<span class="type">Bit</span>] -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">channel</span> = id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; decode (encode "abc")</span></span><br><span class="line"><span class="comment">-- "abc"</span></span><br><span class="line"><span class="comment">-- *Main&gt; (encode "abc")</span></span><br><span class="line"><span class="comment">-- [1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0]</span></span><br><span class="line"><span class="comment">-- *Main&gt; decode [1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,0,1] --&gt; change last bit</span></span><br><span class="line"><span class="comment">-- "*** Exception: Wrong parity bit!</span></span><br><span class="line"><span class="comment">-- CallStack (from HasCallStack):</span></span><br><span class="line"><span class="comment">--   error, called at ch7ex.hs:149:25 in main:Main</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="title">transmit'</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">transmit'</span> = decode.tail.encode</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; transmit "abc"</span></span><br><span class="line"><span class="comment">-- "abc"</span></span><br><span class="line"><span class="comment">-- *Main&gt; transmit' "abc"</span></span><br><span class="line"><span class="comment">-- "*** Exception: Wrong parity bit!</span></span><br><span class="line"><span class="comment">-- CallStack (from HasCallStack):</span></span><br><span class="line"><span class="comment">--   error, called at ch7ex.hs:147:25 in main:Main</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;用map和filter表示-f-x-x-xs-p-x&quot;&gt;用&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;filter&lt;/code&gt;表示&lt;code&gt;[f x | x &amp;lt;- xs, p x]&lt;/code&gt;&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [f x | x &amp;lt;- xs, p x]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [f x | x &amp;lt;- xs, p x]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = map f (filter p xs)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义高阶函数all-any-takewhile-dropwhile&quot;&gt;定义高阶函数&lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;takeWhile&lt;/code&gt;, &lt;code&gt;dropWhile&lt;/code&gt;&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myall&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myall&lt;/span&gt; _ [] = &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myall&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 | otherwise = myall p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myall (&amp;gt;3) [1..3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myall (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myall (&amp;gt;3) [4..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myany&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myany&lt;/span&gt; _ [] = &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myany&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 | otherwise = myany p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myany (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myany (&amp;gt;3) [1..3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mytakeWhile&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mytakeWhile&lt;/span&gt; _ [] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mytakeWhile&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt; = x : mytakeWhile p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       | otherwise = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mytakeWhile (&amp;lt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [1,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mytakeWhile (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mytakeWhile (&amp;lt;3) [1,2,3,1,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [1,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mydropWhile&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mydropWhile&lt;/span&gt; _ [] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mydropWhile&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt; = mydropWhile p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       | otherwise = x : xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mydropWhile (&amp;lt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [3,4,5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mydropWhile (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [1,2,3,4,5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter6 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/28/PIHex6/"/>
    <id>http://duanyifu.com/2016/08/28/PIHex6/</id>
    <published>2016-08-28T13:13:36.000Z</published>
    <updated>2016-08-28T15:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><p>这一章节就是在讲递归，所以下面的定义都是默认用递归定义。</p><h4 id="定义幂函数">定义幂函数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mypow</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">mypow</span> _ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">mypow</span> x n = x * mypow x (n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mypow 2 3</span></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="comment">-- *Main&gt; mypow 3 0</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- *Main&gt; mypow 3 1</span></span><br><span class="line"><span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><h4 id="解释length-drop-init的递归求值过程">解释<code>length</code>, <code>drop</code>, <code>init</code>的递归求值过程</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- length [1, 2, 3]</span></span><br><span class="line"><span class="comment">-- = 1 + length [2, 3]</span></span><br><span class="line"><span class="comment">-- = 1 + (1 + length [3])</span></span><br><span class="line"><span class="comment">-- = 1 + (1 + (1 + length []))</span></span><br><span class="line"><span class="comment">-- = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- drop 3 [1..5]</span></span><br><span class="line"><span class="comment">-- = drop 2 [2..5]</span></span><br><span class="line"><span class="comment">-- = drop 1 [3..5]</span></span><br><span class="line"><span class="comment">-- = drop 0 [4, 5]</span></span><br><span class="line"><span class="comment">-- = [4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- init [1..3]</span></span><br><span class="line"><span class="comment">-- = 1 : init [2, 3]</span></span><br><span class="line"><span class="comment">-- = 1 : 2 : init [3]</span></span><br><span class="line"><span class="comment">-- = 1 : 2 : []</span></span><br><span class="line"><span class="comment">-- = [1, 2]</span></span><br></pre></td></tr></table></figure><h4 id="定义以下库函数">定义以下库函数</h4><a id="more"></a><h5 id="and">and</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myand</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myand</span> [] = <span class="type">True</span></span><br><span class="line"><span class="title">myand</span> (n : ns) | n == <span class="type">False</span> = <span class="type">False</span></span><br><span class="line">               | otherwise = myand ns</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myand [True, True]</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; myand [True, False]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myand []</span></span><br><span class="line"><span class="comment">-- True</span></span><br></pre></td></tr></table></figure><h5 id="concat">concat</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myconcat</span> :: [[a]] -&gt; [a]</span><br><span class="line"><span class="title">myconcat</span> [] = []</span><br><span class="line"><span class="title">myconcat</span> [[a]] = [a]</span><br><span class="line"><span class="title">myconcat</span> (n : ns) = n ++ myconcat ns</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myconcat []</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; myconcat [[1,2,3]]</span></span><br><span class="line"><span class="comment">-- [1,2,3]</span></span><br><span class="line"><span class="comment">-- *Main&gt; myconcat [[1,2,3],[3,4,5],[2,7]]</span></span><br><span class="line"><span class="comment">-- [1,2,3,3,4,5,2,7]</span></span><br></pre></td></tr></table></figure><h5 id="replicate">replicate</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myreplicate</span> :: <span class="type">Int</span> -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">myreplicate</span> <span class="number">0</span> _ = []</span><br><span class="line"><span class="title">myreplicate</span> n a = a : myreplicate (n - <span class="number">1</span>) a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 0 True</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 1 True</span></span><br><span class="line"><span class="comment">-- [True]</span></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 3 'c'</span></span><br><span class="line"><span class="comment">-- "ccc"</span></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 3 "hs"</span></span><br><span class="line"><span class="comment">-- ["hs","hs","hs"]</span></span><br></pre></td></tr></table></figure><h5 id="none">(!!)</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mynth</span> :: [a] -&gt; <span class="type">Int</span> -&gt; a</span><br><span class="line"><span class="title">mynth</span> (x : xs) <span class="number">0</span> = x</span><br><span class="line"><span class="title">mynth</span> (x : xs) n = mynth xs (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其实这里如果n大于长度应该要抛出一个异常，目前还没学到，先放着</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mynth [1..3] 0</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- *Main&gt; mynth [1..3] 2</span></span><br><span class="line"><span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><h5 id="elem">elem</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myelem</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myelem</span> x [] = <span class="type">False</span></span><br><span class="line"><span class="title">myelem</span> x (n : ns) | x == n = <span class="type">True</span></span><br><span class="line">                  | otherwise = myelem x ns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myelem 0 []</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myelem 0 [1..3]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myelem 3 [1..3]</span></span><br><span class="line"><span class="comment">-- True</span></span><br></pre></td></tr></table></figure><h4 id="定义merge函数">定义<code>merge</code>函数</h4><p>merge: 将两个有序list合并成一个有序list</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">merge</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">merge</span> [] [] = []</span><br><span class="line"><span class="title">merge</span> a [] = a</span><br><span class="line"><span class="title">merge</span> [] a = a</span><br><span class="line"><span class="title">merge</span> (n:ns) (x:xs) | x &gt;= n = n : merge ns (x:xs)</span><br><span class="line">                    | x &lt; n = x : merge (n:ns) xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; merge [1,2,3,4,5] [2,3,5,6,7]</span></span><br><span class="line"><span class="comment">-- [1,2,2,3,3,4,5,5,6,7]</span></span><br><span class="line"><span class="comment">-- *Main&gt; merge [2,5,6] [1,3,4]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">-- *Main&gt; merge [1,3,4] []</span></span><br><span class="line"><span class="comment">-- [1,3,4]</span></span><br><span class="line"><span class="comment">-- *Main&gt; merge [] []</span></span><br><span class="line"><span class="comment">-- []</span></span><br></pre></td></tr></table></figure><h4 id="利用merge定义归并排序msort">利用<code>merge</code>定义归并排序<code>msort</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: [a] -&gt; ([a], [a])</span><br><span class="line"><span class="title">halve</span> xs = <span class="keyword">let</span> hl = (length xs) `div` <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line">            (take hl xs, drop hl xs)</span><br><span class="line"></span><br><span class="line"><span class="title">msort</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">msort</span> [] = []</span><br><span class="line"><span class="title">msort</span> [a] = [a]</span><br><span class="line"><span class="title">msort</span> xs = merge (msort (fst (halve xs))) (msort (snd (halve xs)))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; msort []</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; msort [3,1,2,4]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4]</span></span><br><span class="line"><span class="comment">-- *Main&gt; msort [7,3,4,2,4,5,6,12,33,4,22,2]</span></span><br><span class="line"><span class="comment">-- [2,2,3,4,4,4,5,6,7,12,22,33]</span></span><br></pre></td></tr></table></figure><h4 id="定义sum-take-last">定义<code>sum</code>, <code>take</code>, <code>last</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title">mysum</span> :: <span class="type">Num</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">mysum</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">mysum</span> (x : xs) = x + mysum xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mysum []</span></span><br><span class="line"><span class="comment">-- 0</span></span><br><span class="line"><span class="comment">-- *Main&gt; mysum [1..5]</span></span><br><span class="line"><span class="comment">-- 15</span></span><br><span class="line"><span class="comment">-- *Main&gt; mysum [3.6,7.6,5.77]</span></span><br><span class="line"><span class="comment">-- 16.97</span></span><br><span class="line"></span><br><span class="line"><span class="title">mytake</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mytake</span> <span class="number">0</span> _ = []</span><br><span class="line"><span class="title">mytake</span> _ [] = []</span><br><span class="line"><span class="title">mytake</span> n (x : xs) = x : mytake (n - <span class="number">1</span>) xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 0 [1..5]</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 3 [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2,3]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 7 [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 7 []</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">mylast</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">mylast</span> [x] = x</span><br><span class="line"><span class="title">mylast</span> (x : xs) = mylast xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mylast [1..3]</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- *Main&gt; mylast [5]</span></span><br><span class="line"><span class="comment">-- 5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这一章节就是在讲递归，所以下面的定义都是默认用递归定义。&lt;/p&gt;
&lt;h4 id=&quot;定义幂函数&quot;&gt;定义幂函数&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mypow&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mypow&lt;/span&gt; _ &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mypow&lt;/span&gt; x n = x * mypow x (n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mypow 2 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mypow 3 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mypow 3 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;解释length-drop-init的递归求值过程&quot;&gt;解释&lt;code&gt;length&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt;的递归求值过程&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- length [1, 2, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 + length [2, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 + (1 + length [3])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 + (1 + (1 + length []))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- drop 3 [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = drop 2 [2..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = drop 1 [3..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = drop 0 [4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = [4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- init [1..3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 : init [2, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 : 2 : init [3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 : 2 : []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = [1, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义以下库函数&quot;&gt;定义以下库函数&lt;/h4&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter5 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/27/PIHex5/"/>
    <id>http://duanyifu.com/2016/08/27/PIHex5/</id>
    <published>2016-08-27T15:13:37.000Z</published>
    <updated>2016-08-28T15:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="用list-comprehension计算1到100平方和">用List Comprehension计算1到100平方和</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [x^<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.100</span>]]</span><br></pre></td></tr></table></figure><h4 id="定义库函数replicate">定义库函数<code>replicate</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &gt; replicate 3 True</span></span><br><span class="line"><span class="comment">-- [True, True, True]</span></span><br><span class="line"></span><br><span class="line"><span class="title">myreplicate</span> :: <span class="type">Int</span> -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">myreplicate</span> n x = [x | _ &lt;- [<span class="number">1.</span>.n]]</span><br></pre></td></tr></table></figure><h4 id="定义函数pyths">定义函数<code>pyths</code></h4><p><code>pyths n</code>返回满足<code>x^2 + y^2 == z^2</code>的三元组<code>(x, y, z)</code>，其中xyz都小于等于n</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &gt; paths 10</span></span><br><span class="line"><span class="comment">-- [(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]</span></span><br><span class="line"></span><br><span class="line"><span class="title">pyths</span>   :: <span class="type">Int</span> -&gt; [(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)]</span><br><span class="line"><span class="title">pyths</span> n = [(x,y,z) | x &lt;- [<span class="number">1.</span>.n],</span><br><span class="line">                     y &lt;- [<span class="number">1.</span>.n],</span><br><span class="line">                     z &lt;- [<span class="number">1.</span>.n],</span><br><span class="line">                     x^<span class="number">2</span> + y^<span class="number">2</span> == z^<span class="number">2</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="定义完美数函数perfects">定义完美数函数<code>perfects</code></h4><p>完美数的定义：一个数所有的真因子（除掉自身以外的因子）之和等于它本身。<br>例如：6 = 1 + 2 + 3</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factors</span> :: <span class="type">Int</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">factors</span> x = [n | n &lt;- [<span class="number">1.</span>.x<span class="number">-1</span>], x `mod` n == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">perfects</span> :: <span class="type">Int</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">perfects</span> n = [x | x &lt;- [<span class="number">1.</span>.n], x == sum (factors x)]</span><br></pre></td></tr></table></figure><p>深入阅读：<a href="https://en.wikipedia.org/wiki/Perfect_number" target="_blank" rel="noopener">Perfect number</a></p><h4 id="改写-x-y-x-1-3-y-1-3">改写<code>[(x, y) | x &lt;- [1..3], y &lt;- [1..3]]</code></h4><p>将两层List Comprehension嵌套起来</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">concat</span> [[(x,y)| x &lt;- [<span class="number">1.</span><span class="number">.3</span>] ]| y &lt;- [<span class="number">1.</span><span class="number">.3</span>]]</span><br></pre></td></tr></table></figure><h4 id="利用find函数重新定义positions函数">利用<code>find</code>函数重新定义<code>positions</code>函数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">positions</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">positions</span> x xs = [i | (x', i) &lt;- zip xs [<span class="number">0.</span>.n], x == x']</span><br><span class="line">                    <span class="keyword">where</span> n = length xs <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="title">find</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [(a, b)] -&gt; [b]</span><br><span class="line"><span class="title">find</span> k t = [v | (k', v) &lt;- t, k == k']</span><br></pre></td></tr></table></figure><h4 id="计算内积函数scalarproduct">计算内积函数<code>scalarproduct</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">scalarproduct</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">scalarproduct</span> x y = sum [x * y | (x, y) &lt;- zip x y]</span><br></pre></td></tr></table></figure><h4 id="修改书上的caesar-cipher程序-使之能处理大写字母">修改书上的Caesar cipher程序，使之能处理大写字母</h4><p>思路是：</p><ol><li>用<code>shift</code>进行移位的时候，将大写字母、小写字母分开处理；</li><li>crack计算概率的时候，把大写字母当做小写字母处理。</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let2int</span> :: <span class="type">Char</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">let2int</span> c = ord c - ord 'a'</span><br><span class="line"></span><br><span class="line"><span class="comment">-- new</span></span><br><span class="line"><span class="title">let2intup</span> :: <span class="type">Char</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">let2intup</span> c = ord c - ord '<span class="type">A'</span></span><br><span class="line"></span><br><span class="line"><span class="title">int2let</span> :: <span class="type">Int</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">int2let</span> n = chr (ord 'a' + n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- new</span></span><br><span class="line"><span class="title">int2letup</span> :: <span class="type">Int</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">int2letup</span> n = chr (ord '<span class="type">A'</span> + n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- modified</span></span><br><span class="line"><span class="title">shift</span> :: <span class="type">Int</span> -&gt; <span class="type">Char</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">shift</span> n c | isLower c = int2let ((let2int c + n) `mod` <span class="number">26</span>)</span><br><span class="line">          | isUpper c = int2letup ((let2intup c + n) `mod` <span class="number">26</span>)</span><br><span class="line">          | otherwise = c</span><br><span class="line"></span><br><span class="line"><span class="title">table</span> :: [<span class="type">Float</span>]</span><br><span class="line"><span class="title">table</span> = [<span class="number">8.2</span>, <span class="number">1.5</span>, <span class="number">2.8</span>, <span class="number">4.3</span>, <span class="number">12.7</span>, <span class="number">2.2</span>,</span><br><span class="line">         <span class="number">2.0</span>, <span class="number">6.1</span>, <span class="number">7.0</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">4.0</span>,</span><br><span class="line">         <span class="number">2.4</span>, <span class="number">6.7</span>, <span class="number">7.5</span>, <span class="number">1.9</span>, <span class="number">0.1</span>, <span class="number">6.0</span>,</span><br><span class="line">         <span class="number">6.3</span>, <span class="number">9.1</span>, <span class="number">2.8</span>, <span class="number">1.0</span>, <span class="number">2.4</span>, <span class="number">0.2</span>,</span><br><span class="line">         <span class="number">2.0</span>, <span class="number">0.1</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">encode</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">encode</span> n xs = [shift n x | x &lt;- xs]</span><br><span class="line"></span><br><span class="line"><span class="title">percent</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">percent</span> n m = (fromIntegral n / fromIntegral m) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="title">count</span> :: <span class="type">Char</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">count</span> x xs = length [x' | x' &lt;- xs, x == x']</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lowers :: String -&gt; Int</span></span><br><span class="line"><span class="comment">-- lowers xs = length [x | x &lt;- xs, isLower x]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- new</span></span><br><span class="line"><span class="title">lowerstring</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lowerstring</span> xs = [<span class="keyword">if</span> isUpper x <span class="keyword">then</span> chr (ord x + <span class="number">32</span>) <span class="keyword">else</span> x| x &lt;- xs]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- modified</span></span><br><span class="line"><span class="title">freqs</span> :: <span class="type">String</span> -&gt; [<span class="type">Float</span>]</span><br><span class="line"><span class="title">freqs</span> xs = [percent (count x (lowerstring xs)) n | x &lt;- ['a'..'z']]</span><br><span class="line">            <span class="keyword">where</span> n = length xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- chi-square</span></span><br><span class="line"><span class="title">chisqr</span> :: [<span class="type">Float</span>] -&gt; [<span class="type">Float</span>] -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">chisqr</span> os es = sum [(o - e)^<span class="number">2</span> / e | (o, e) &lt;- zip os es]</span><br><span class="line"></span><br><span class="line"><span class="title">rotate</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">rotate</span> n xs = drop n xs ++ take n xs</span><br><span class="line"></span><br><span class="line"><span class="title">crack</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">crack</span> xs = encode (-factor) xs</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        factor = head (positions (minimum chitab) chitab)</span><br><span class="line">        chitab = [chisqr (rotate n table') table | n &lt;- [<span class="number">0.</span><span class="number">.25</span>]]</span><br><span class="line">        table' = freqs xs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :l ch5ex.hs </span><br><span class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">Main</span>             ( ch5ex.hs, interpreted )</span><br><span class="line"><span class="type">Ok</span>, modules loaded: <span class="type">Main</span>.</span><br><span class="line">*<span class="type">Main</span>&gt; encode <span class="number">3</span> <span class="string">"HasKELL iS FuN"</span></span><br><span class="line"><span class="string">"KdvNHOO lV IxQ"</span></span><br><span class="line">*<span class="type">Main</span>&gt; crack <span class="string">"KDvnhoO Lv IXQ"</span></span><br><span class="line"><span class="string">"HAskelL Is FUN"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;用list-comprehension计算1到100平方和&quot;&gt;用List Comprehension计算1到100平方和&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt; [x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; | x &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.100&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义库函数replicate&quot;&gt;定义库函数&lt;code&gt;replicate&lt;/code&gt;&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- &amp;gt; replicate 3 True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [True, True, True]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myreplicate&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; a -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myreplicate&lt;/span&gt; n x = [x | _ &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义函数pyths&quot;&gt;定义函数&lt;code&gt;pyths&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;pyths n&lt;/code&gt;返回满足&lt;code&gt;x^2 + y^2 == z^2&lt;/code&gt;的三元组&lt;code&gt;(x, y, z)&lt;/code&gt;，其中xyz都小于等于n&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- &amp;gt; paths 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pyths&lt;/span&gt;   :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; [(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pyths&lt;/span&gt; n = [(x,y,z) | x &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     y &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     z &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + y^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == z^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter4 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/26/PIHex4/"/>
    <id>http://duanyifu.com/2016/08/26/PIHex4/</id>
    <published>2016-08-25T17:00:18.000Z</published>
    <updated>2016-08-28T15:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="定义-halve">定义 halve</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: [a] -&gt; ([a], [a])</span><br><span class="line"><span class="title">halve</span> a = <span class="keyword">let</span> n = (length a) `div` <span class="number">2</span> <span class="keyword">in</span> (take n a, drop n a)</span><br></pre></td></tr></table></figure><h4 id="用三种方式定义safetail">用三种方式定义safetail</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- conditional expression</span></span><br><span class="line"><span class="title">safetail1</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">safetail1</span> xs = <span class="keyword">if</span> null xs <span class="keyword">then</span> xs <span class="keyword">else</span> tail xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- guarded equations</span></span><br><span class="line"><span class="title">safetail2</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">safetail2</span> xs | null xs      = xs</span><br><span class="line">             | otherwise    = tail xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- pattern matching</span></span><br><span class="line"><span class="title">safetail3</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">safetail3</span> [] = []</span><br><span class="line"><span class="title">safetail3</span> (_:xs) = xs</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="定义并运算-disjunction-operator">定义并运算（disjunction operator）</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1 all pattern matching</span></span><br><span class="line"><span class="title">md1</span> :: <span class="type">Bool</span> -&gt; <span class="type">Bool</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">md1</span> <span class="type">True</span> <span class="type">True</span> = <span class="type">True</span></span><br><span class="line"><span class="title">md1</span> <span class="type">True</span> <span class="type">False</span> = <span class="type">True</span></span><br><span class="line"><span class="title">md1</span> <span class="type">False</span> <span class="type">True</span> = <span class="type">True</span></span><br><span class="line"><span class="title">md1</span> <span class="type">False</span> <span class="type">False</span> = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2 wildcard pattern</span></span><br><span class="line"></span><br><span class="line"><span class="title">md2</span> <span class="type">False</span> <span class="type">False</span> = <span class="type">False</span></span><br><span class="line"><span class="title">md2</span> _ _ = <span class="type">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="title">md3</span> <span class="type">False</span> b = b</span><br><span class="line"><span class="title">md3</span> <span class="type">True</span> _ = <span class="type">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4</span></span><br><span class="line"><span class="title">md4</span> a b | a == b    = a</span><br><span class="line">        | otherwise = <span class="type">True</span></span><br></pre></td></tr></table></figure><h4 id="用条件表达式-conditional-expressions-重新定义并运算">用条件表达式（conditional expressions）重新定义并运算</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mc1</span> a b = <span class="keyword">if</span> a == <span class="type">False</span> <span class="keyword">then</span> <span class="type">False</span> <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> b == <span class="type">True</span> <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> <span class="type">False</span></span><br></pre></td></tr></table></figure><h4 id="同上一题">同上一题</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mc2</span> a b = <span class="keyword">if</span> a == <span class="type">True</span> <span class="keyword">then</span> b <span class="keyword">else</span> <span class="type">False</span></span><br></pre></td></tr></table></figure><h4 id="用lambda表达式理解函数mult-x-y-z-x-y-z">用lambda表达式理解函数<code>mult x y z = x * y * z</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mult</span> x y z == \x -&gt; (\y -&gt; (\z -&gt; x * y * z))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;定义-halve&quot;&gt;定义 halve&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;halve&lt;/span&gt; :: [a] -&amp;gt; ([a], [a])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;halve&lt;/span&gt; a = &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; n = (length a) `div` &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (take n a, drop n a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;用三种方式定义safetail&quot;&gt;用三种方式定义safetail&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- conditional expression&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail1&lt;/span&gt; :: [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail1&lt;/span&gt; xs = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; null xs &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; xs &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; tail xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- guarded equations&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail2&lt;/span&gt; :: [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail2&lt;/span&gt; xs | null xs      = xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             | otherwise    = tail xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- pattern matching&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail3&lt;/span&gt; :: [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail3&lt;/span&gt; [] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail3&lt;/span&gt; (_:xs) = xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter3 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/25/PIHex3/"/>
    <id>http://duanyifu.com/2016/08/25/PIHex3/</id>
    <published>2016-08-25T15:45:14.000Z</published>
    <updated>2016-08-25T17:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="写出这些表达式的type">写出这些表达式的type</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">['a', 'b', 'c']             <span class="comment">-- :: [Char]</span></span><br><span class="line">('a', 'b', 'c')             <span class="comment">-- :: (Char, Char, Char)</span></span><br><span class="line">[(<span class="type">False</span>, '<span class="type">O'</span>), (<span class="type">True</span>, '<span class="number">1</span>')] <span class="comment">-- :: [(Bool, Char)]</span></span><br><span class="line">([<span class="type">False</span>, <span class="type">True</span>], ['<span class="number">0</span>', '<span class="number">1</span>']) <span class="comment">-- :: ([Bool], [Char])</span></span><br><span class="line">[tail, init, reverse]       <span class="comment">-- :: [[a] -&gt; [a]]</span></span><br></pre></td></tr></table></figure><h4 id="写出这些函数的type">写出这些函数的type</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">second</span> xs       = head (tail xs)    <span class="comment">-- [a] -&gt; a</span></span><br><span class="line"><span class="title">swap</span> (x, y)     = (y, x)            <span class="comment">-- (a, b) -&gt; (b, a)</span></span><br><span class="line"><span class="title">pair</span> x y        = (x, y)            <span class="comment">-- a -&gt; b -&gt; (a, b)</span></span><br><span class="line"><span class="title">double</span> x        = x * <span class="number">2</span>             <span class="comment">-- Num a =&gt; a -&gt; a</span></span><br><span class="line"><span class="title">palindrome</span> xs   = reverse xs == xs  <span class="comment">-- Eq a =&gt; a -&gt; Bool</span></span><br><span class="line"><span class="title">twice</span> f x       = f (f x)           <span class="comment">-- (a -&gt; a) -&gt; a -&gt; a</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="在hugs中验证前两题">在Hugs中验证前两题</h4><p>第二题中，有几个函数用<code>:t</code>查看的type是用<code>t</code> <code>t1</code>表示的，和<code>a</code> <code>b</code>是一个意思。</p><h4 id="为什么-将所有的函数类型都定义为eq-class的实例-instance-是不可行的？">为什么“将所有的函数类型都定义为<code>Eq class</code>的实例（instance）”是不可行的？</h4><p>题目中给出的两个函数相等的定义是这样：</p><ol><li>type相同</li><li>对于任意的输入，都拥有相同的输出</li></ol><p>显然，编译器不可能对两个函数测试所有的参数来判断它们是否相等。因为可能的参数是有无穷多个的。</p><p>深入阅读: <a href="http://stackoverflow.com/questions/10956419/why-isnt-every-type-part-of-eq-in-haskell" target="_blank" rel="noopener">Why isn’t every type part of Eq in Haskell?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写出这些表达式的type&quot;&gt;写出这些表达式的type&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]             &lt;span class=&quot;comment&quot;&gt;-- :: [Char]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)             &lt;span class=&quot;comment&quot;&gt;-- :: (Char, Char, Char)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;, &#39;&lt;span class=&quot;type&quot;&gt;O&#39;&lt;/span&gt;), (&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &#39;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&#39;)] &lt;span class=&quot;comment&quot;&gt;-- :: [(Bool, Char)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;([&lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;], [&#39;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&#39;, &#39;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&#39;]) &lt;span class=&quot;comment&quot;&gt;-- :: ([Bool], [Char])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tail, init, reverse]       &lt;span class=&quot;comment&quot;&gt;-- :: [[a] -&amp;gt; [a]]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;写出这些函数的type&quot;&gt;写出这些函数的type&lt;/h4&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;second&lt;/span&gt; xs       = head (tail xs)    &lt;span class=&quot;comment&quot;&gt;-- [a] -&amp;gt; a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt; (x, y)     = (y, x)            &lt;span class=&quot;comment&quot;&gt;-- (a, b) -&amp;gt; (b, a)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pair&lt;/span&gt; x y        = (x, y)            &lt;span class=&quot;comment&quot;&gt;-- a -&amp;gt; b -&amp;gt; (a, b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;double&lt;/span&gt; x        = x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;             &lt;span class=&quot;comment&quot;&gt;-- Num a =&amp;gt; a -&amp;gt; a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;palindrome&lt;/span&gt; xs   = reverse xs == xs  &lt;span class=&quot;comment&quot;&gt;-- Eq a =&amp;gt; a -&amp;gt; Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;twice&lt;/span&gt; f x       = f (f x)           &lt;span class=&quot;comment&quot;&gt;-- (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>用Sublime Text写Haskell</title>
    <link href="http://duanyifu.com/2016/08/24/write-haskell-with-sublime/"/>
    <id>http://duanyifu.com/2016/08/24/write-haskell-with-sublime/</id>
    <published>2016-08-23T18:09:20.000Z</published>
    <updated>2016-08-23T20:00:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础准备">基础准备</h3><ul><li><a href="https://www.haskell.org/downloads" target="_blank" rel="noopener">Haskell</a> (我选择的是Haskell Platform 8.0.1)</li><li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text</a></li><li><a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control: The Sublime Text package manager</a></li></ul><h3 id="安装插件">安装插件</h3><h4 id="sublimehaskell">SublimeHaskell</h4><p>在Package Control中安装SublimeHaskell。<br>插件安装完成后，重启Sublime报错，提示需要安装hsdev cabal package。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SublimeHaskell: hsdev executable couldn&apos;t be found!</span><br><span class="line">It&apos;s used in most features of SublimeHaskell</span><br><span class="line">Check if it&apos;s installed and in PATH</span><br><span class="line">If it&apos;s not installed, run &apos;cabal install hsdev&apos; to install hsdev</span><br><span class="line">You may also want to adjust &apos;add_to_PATH&apos; setting</span><br></pre></td></tr></table></figure><a id="more"></a><p>用cabal安装之：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install hsdev</span><br></pre></td></tr></table></figure><p>然后是cabal运行过程中报错，提示缺少happy cabal package。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install hsdev</span><br><span class="line">Resolving dependencies...</span><br><span class="line">Configuring haskell-src-exts-1.17.1...</span><br><span class="line">Failed to install haskell-src-exts-1.17.1</span><br><span class="line">Build log ( /Users/mist/.cabal/logs/haskell-src-exts-1.17.1.log ):</span><br><span class="line">cabal: Entering directory &apos;/var/folders/4f/s20y12v152dgfl1rqbs3ztfc0000gn/T/cabal-tmp-245/haskell-src-exts-1.17.1&apos;</span><br><span class="line">Configuring haskell-src-exts-1.17.1...</span><br><span class="line">cabal.real: The program &apos;happy&apos; version &gt;=1.19 is required but it could not be</span><br><span class="line">found.</span><br><span class="line">cabal: Leaving directory &apos;/var/folders/4f/s20y12v152dgfl1rqbs3ztfc0000gn/T/cabal-tmp-245/haskell-src-exts-1.17.1&apos;</span><br><span class="line">cabal: Error: some packages failed to install:</span><br><span class="line">haskell-src-exts-1.17.1 failed during the configure step. The exception was:</span><br><span class="line">ExitFailure 1</span><br><span class="line">hlint-1.9.35 depends on haskell-src-exts-1.17.1 which failed to install.</span><br><span class="line">hsdev-0.2.0.0 depends on haskell-src-exts-1.17.1 which failed to install.</span><br></pre></td></tr></table></figure><p>遂先装happy，再来装hsdev。<br>(PS: 这个hsdev包安装过程中的各种build超超超慢)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install happy</span><br><span class="line">$ cabal install hsdev  </span><br></pre></td></tr></table></figure><p>等了好久终于装好了，结果打开Sublime依然报错，还需要手动配置SublimeHaskell。<br>菜单栏选<code>Preferences -&gt; Package Settings -&gt; SublimeHaskell -&gt; Settings - User</code>进行配置，文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"add_to_PATH"</span>:</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"/Users/mist/Library/Haskell/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"enable_ghc_mod"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"enable_hdevtools"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意：文件中的路径应当修改为你自己的路径，可以用<code>cat ~/.cabal/where-is-my-stuff.txt</code>查看。</strong></p><p>再次重启sublime，这次没有报错。</p><h4 id="sublimerepl">SublimeREPL</h4><p>在Package Control中安装SublimeREPL。<br>这个插件可以直接新建一个tab用来跑GHCi，配合<code>View -&gt; Layout -&gt; Coloum: 2</code>使用，方便开发与调试。</p><h4 id="stylish-haskell">stylish-haskell</h4><p>有待研究。</p><h3 id="测试一下">测试一下</h3><h4 id="自带build-system可以使用">自带Build System可以使用</h4><p><code>Tools -&gt; Build System -&gt; Automatic 或 Haskell</code><br>直接运行当前文件。<br><img src="http://ocdmsdl3m.bkt.clouddn.com/sublime_haskell_1.png" alt="sublime build system"></p><h4 id="sublimehaskell常用命令">SublimeHaskell常用命令</h4><p>显示声明位置：<code>f12</code><br>详细声明文档：<code>ctrl+k ctrl+i</code><br>显示类型：<code>ctrl+k ctrl+h ctrl+t</code><br>插入类型：<code>ctrl+k ctrl+i ctrl+i</code><br>当然，也可以用<code>command+shift+p</code>调用这些命令。</p><h4 id="sublimerepl-v2">SublimeREPL</h4><p>不用额外配置，通过<code>Tools -&gt; SublimeREPL -&gt; Haskell</code>可以直接打开GHCi。</p><h3 id="总结">总结</h3><p>生命不息，折腾不止，终于可以愉快地敲haskell啦~<br>主要的坑都在cabal上，cabal这个包管理比起 pip npm 啥的实在太弱了，连uninstall都没有！(敲<code>cabal uninstall</code>会告诉你以后会加上这个功能的。。。)</p><h3 id="参考">参考</h3><ol><li><a href="https://github.com/SublimeHaskell/SublimeHaskell" target="_blank" rel="noopener">SublimeHaskell GitHub repo</a></li><li><a href="http://tonylawrence.com/2014/01/01/configuring-your-haskell-environment/" target="_blank" rel="noopener">Configuring your Haskell environment</a></li><li><a href="http://umairsaeed.com/blog/2015/05/02/sublime-text-and-haskell/" target="_blank" rel="noopener">Sublime Text &amp; Haskell</a></li><li><a href="https://github.com/jaspervdj/stylish-haskell" target="_blank" rel="noopener">stylish-haskell GitHub repo</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础准备&quot;&gt;基础准备&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.haskell.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell&lt;/a&gt; (我选择的是Haskell Platform 8.0.1)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sublimetext.com/3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sublime Text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Package Control: The Sublime Text package manager&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装插件&quot;&gt;安装插件&lt;/h3&gt;
&lt;h4 id=&quot;sublimehaskell&quot;&gt;SublimeHaskell&lt;/h4&gt;
&lt;p&gt;在Package Control中安装SublimeHaskell。&lt;br&gt;
插件安装完成后，重启Sublime报错，提示需要安装hsdev cabal package。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SublimeHaskell: hsdev executable couldn&amp;apos;t be found!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;It&amp;apos;s used in most features of SublimeHaskell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Check if it&amp;apos;s installed and in PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;If it&amp;apos;s not installed, run &amp;apos;cabal install hsdev&amp;apos; to install hsdev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You may also want to adjust &amp;apos;add_to_PATH&amp;apos; setting&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Sublime" scheme="http://duanyifu.com/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter2 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/23/PIHex2/"/>
    <id>http://duanyifu.com/2016/08/23/PIHex2/</id>
    <published>2016-08-23T07:13:53.000Z</published>
    <updated>2016-08-28T15:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="给算数表达式加上括号">给算数表达式加上括号</h4><p>按照运算符优先级就可以，略过。</p><h4 id="修改代码-使之正确">修改代码，使之正确</h4><p>将<code>length xs</code>用括号括起来即可。</p><h4 id="尝试定义last">尝试定义<code>last</code></h4><p><code>last</code>: 返回非空list的最后一个元素</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mylast</span> a = a !! ((length a) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="尝试定义init">尝试定义<code>init</code></h4><p><code>init</code>: 删除非空list的最后一个元素，并返回list</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myinit1</span> a = take ((length a) - <span class="number">1</span>) a</span><br><span class="line"></span><br><span class="line"><span class="title">myinit2</span> a = <span class="keyword">let</span> n = length a <span class="keyword">in</span> reverse (tail (reverse a))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; targe
      
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>hexo deploy 命令卡住的奇怪问题</title>
    <link href="http://duanyifu.com/2016/08/23/hexo-deploy-problem/"/>
    <id>http://duanyifu.com/2016/08/23/hexo-deploy-problem/</id>
    <published>2016-08-22T18:25:10.000Z</published>
    <updated>2016-08-22T18:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p>用<code>hexo d</code>命令部署的时候总是会卡住很久，反复尝试了几次后，每次都是control+C告终。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ hexo d</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">^CINFO  Bye!</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>hexo d -debug</code>查看日志发现信息一直在循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">▶ hexo deploy -debug</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 620 ms</span><br><span class="line">INFO  0 files generated in 518 ms</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 468 ms</span><br><span class="line">INFO  0 files generated in 363 ms</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 342 ms</span><br><span class="line">...</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 274 ms</span><br><span class="line">INFO  0 files generated in 381 ms</span><br><span class="line">INFO  Start processing</span><br><span class="line">^CINFO  Bye!</span><br></pre></td></tr></table></figure><h3 id="解决办法">解决办法</h3><p>首先检查_config.yml文件，看看deployment相关配置写对了没</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:mistwave/mistwave.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>对照官方文档后，发现配置并没有错，推测是ssh的问题。<br>将repo改成https地址后，问题依旧存在。</p><p>找了一些类似问题的资料后，尝试了删除<code>.deploy_git</code>，更新git版本后，问题依然没有解决。</p><p>但是在删除<code>.deploy_git</code>后，发现总是在gitlog后面卡住，推测是<code>git push</code>的问题，尝试让git走代理，问题解决，令人哭笑不得。</p><p>git配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><p>设置的意思是让http/https协议走代理，即Shadowsocks的本地代理。</p><h3 id="参考文章">参考文章</h3><ol><li><a href="https://github.com/hexojs/hexo/issues/1478" target="_blank" rel="noopener">hexo repo上一个类似issues</a></li><li><a href="http://www.wuliaole.com/post/the_lag_problem_for_hexo_deploying_on_github/" target="_blank" rel="noopener">hexo在github部署卡住的奇怪问题</a></li><li><a href="http://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/index.html" target="_blank" rel="noopener">为终端设置Shadowsocks代理</a></li><li><a href="http://blog.fazero.cc/2015/07/11/%E7%94%A8shadowsocks%E5%8A%A0%E9%80%9Fgit-clone/" target="_blank" rel="noopener">用shadowsocks加速git clone</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;用&lt;code&gt;hexo d&lt;/code&gt;命令部署的时候总是会卡住很久，反复尝试了几次后，每次都是control+C告终。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;▶ hexo d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO  Deploying: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO  Clearing .deploy_git folder...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO  Copying files from public folder...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nothing to commit, working directory clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^CINFO  Bye!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="疑难杂症" scheme="http://duanyifu.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="hexo" scheme="http://duanyifu.com/tags/hexo/"/>
    
      <category term="git" scheme="http://duanyifu.com/tags/git/"/>
    
      <category term="shadowsocks" scheme="http://duanyifu.com/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter1 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/22/PIHex1/"/>
    <id>http://duanyifu.com/2016/08/22/PIHex1/</id>
    <published>2016-08-22T15:47:22.000Z</published>
    <updated>2016-08-28T15:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="给出double-double-2-的另外一种可能解释">给出<code>double (double 2)</code>的另外一种可能解释。</h4><p>书上给的例子是应用序和正则序（从左向右），可以将正则序（从右向左）当作答案。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">double</span> (double <span class="number">2</span>)</span><br><span class="line">= double <span class="number">2</span> + double <span class="number">2</span></span><br><span class="line">= double <span class="number">2</span> + (<span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">= double <span class="number">2</span> + <span class="number">4</span></span><br><span class="line">= (<span class="number">2</span> + <span class="number">2</span>) + <span class="number">4</span></span><br><span class="line">= <span class="number">4</span> + <span class="number">4</span></span><br><span class="line">= <span class="number">8</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="解释sum-x-的求值过程">解释<code>sum [x]</code>的求值过程。</h4><p>sum的定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum</span> (x:xs) = x + sum xs</span><br></pre></td></tr></table></figure><p>sum [x] 求值过程：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [x]</span><br><span class="line">= x + sum []</span><br><span class="line">= x + <span class="number">0</span></span><br><span class="line">= x</span><br></pre></td></tr></table></figure><h4 id="定义product">定义<code>product</code>。</h4><p>仿照sum的定义，将product定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> []     = <span class="number">1</span></span><br><span class="line"><span class="title">product</span> (x:xs) = x * sum xs</span><br></pre></td></tr></table></figure><p>product [2, 3, 4]求值过程：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * product [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * product [<span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * product []</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">1</span></span><br><span class="line">= <span class="number">24</span></span><br></pre></td></tr></table></figure><h4 id="将qsort改成输出倒序的">将<code>qsort</code>改成输出倒序的。</h4><p>将课本中的例子larger和smaller交换即可。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- qsort.hs</span></span><br><span class="line"><span class="title">qsort</span> [] = []</span><br><span class="line"><span class="title">qsort</span> (x:xs) = qsort larger ++ [x] ++ qsort smaller</span><br><span class="line">               <span class="keyword">where</span></span><br><span class="line">                larger = [a | a &lt;- xs, a &gt; x]</span><br><span class="line">                smaller = [b | b &lt;- xs, b &lt;= x]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- *Main&gt; qsort [3,5,1,4,2]</span></span><br><span class="line"><span class="comment">--- [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><h4 id="将qsort定义中的-换成-会如何">将<code>qsort</code>定义中的<code>&lt;=</code>换成<code>&lt;</code>会如何。</h4><p>若将<code>&lt;=</code>换成<code>&lt;</code>，则与<code>x</code>相等的元素将会丢失。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; qsort [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">this</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;给出double-double-2-的另外一种可能解释&quot;&gt;给出&lt;code&gt;double (double 2)&lt;/code&gt;的另外一种可能解释。&lt;/h4&gt;
&lt;p&gt;书上给的例子是应用序和正则序（从左向右），可以将正则序（从右向左）当作答案。&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;double&lt;/span&gt; (double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
</feed>
