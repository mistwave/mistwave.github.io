<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yifu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://duanyifu.com/"/>
  <updated>2019-07-28T14:36:08.583Z</updated>
  <id>http://duanyifu.com/</id>
  
  <author>
    <name>Yifu Duan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Monoid in Functional Programming</title>
    <link href="http://duanyifu.com/2019/07/28/Monoid%20in%20Functional%20Programming/"/>
    <id>http://duanyifu.com/2019/07/28/Monoid in Functional Programming/</id>
    <published>2019-07-28T11:31:56.000Z</published>
    <updated>2019-07-28T14:36:08.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Monoid-是什么？"><a href="#Monoid-是什么？" class="headerlink" title="Monoid 是什么？"></a>Monoid 是什么？</h2><p>我们先看两组例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string concatenation</span></span><br><span class="line">concat(<span class="string">"foo"</span>,<span class="string">"bar"</span>) == <span class="string">"foobar"</span></span><br><span class="line">concat(<span class="string">""</span>, <span class="string">"latte"</span>) == concat(<span class="string">"latte"</span>, <span class="string">""</span>) == <span class="string">"latte"</span></span><br><span class="line">concat(<span class="string">"a"</span>, concat(<span class="string">"b"</span>, <span class="string">"c"</span>)) == concat(concat(<span class="string">"a"</span>, <span class="string">"b"</span>), <span class="string">"c"</span>) == <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// integer addition</span></span><br><span class="line"><span class="number">3</span> + <span class="number">5</span> == <span class="number">8</span></span><br><span class="line"><span class="number">0</span> + <span class="number">42</span> == <span class="number">42</span> + <span class="number">0</span> == <span class="number">42</span></span><br><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="number">3</span>) == (<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span> == <span class="number">6</span></span><br></pre></td></tr></table></figure><p>我们可以发现，这两组操作其实有着相同的模式：</p><ul><li>有一个“零值”，记作<code>zero</code>，例子中分别是<code>空串</code>和<code>0</code></li><li>有一个二元操作符，记作<code>op</code>，例子中分别是<code>concat</code>和<code>+</code></li><li><code>op</code>满足结合律（associativity），即<code>op(x, op(y, z)) == op(op(x, y), z)</code></li><li>零值是单位元，即<code>op(zero, x) == op(x, zero) == x</code><a id="more"></a></li></ul><p>那么我们可以这样表示monoid：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(m: <span class="type">A</span>, n: <span class="type">A</span>): <span class="type">A</span> <span class="comment">// 满足 op(x, op(y, z)) == op(op(x, y), z)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span> <span class="comment">// 满足 op(zero, x) == op(x, zero) == x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，monoid是十分普遍的，比如：</p><ol><li>乘法，单位元是1</li><li>布尔运算<code>&amp;&amp;</code>，单位元是<code>true</code></li><li>求<code>Integer</code>的最大值<code>max</code>，单位元是<code>Integer.MIN_VALUE</code></li><li><code>List</code>的连接，单位元是<code>Nil（空列表）</code></li><li>自函数（参数与返回值的类型相同，即类型为<code>A =&gt; A</code>的函数）的组合<code>compose</code>，单位元是<code>id</code></li></ol><p>第5个并不是那么显而易见，实现如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">endoMonoid</span></span>[<span class="type">A</span>]: <span class="type">Monoid</span>[<span class="type">A</span> =&gt; <span class="type">A</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">A</span> =&gt; <span class="type">A</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(f: <span class="type">A</span> =&gt; <span class="type">A</span>, g: <span class="type">A</span> =&gt; <span class="type">A</span>): <span class="type">A</span> =&gt; <span class="type">A</span> = </span><br><span class="line">    g compose f <span class="comment">// you can choose (g compose f) or (f compose g)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>: <span class="type">A</span> =&gt; <span class="type">A</span> = </span><br><span class="line">    (x =&gt; x) <span class="comment">// aka. id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么monoid是什么？</p><p><strong>一个可结合的二元操作符和一个单位元元素，构成一个monoid。</strong></p><h2 id="Monoid-有什么用？"><a href="#Monoid-有什么用？" class="headerlink" title="Monoid 有什么用？"></a>Monoid 有什么用？</h2><p>Monoid是一种抽象，我们总是可以通过抽象来写出<strong>更加通用的代码</strong>：事实上，我们可以不关心monoid里的具体类型，直接写出可以对任何monoid都有效的代码。</p><h3 id="计算的灵活性"><a href="#计算的灵活性" class="headerlink" title="计算的灵活性"></a>计算的灵活性</h3><p>事实上，对于monoid，我们并不关心计算发生的顺序，结合律保证了结果的一致：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. foldRight</span></span><br><span class="line">a + (b + (c + (d + (e + (f + (g + h))))))</span><br><span class="line"><span class="comment">// 2. foldLeft</span></span><br><span class="line">((((((a + b) + c) + d) + e) + f) + g) + h</span><br><span class="line"><span class="comment">// 3. run in parallel</span></span><br><span class="line">(a + b + c) + (d + e + f) + (g + h + <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 4. fold like a binary tree</span></span><br><span class="line">((a + b) + (c + d)) + ((e + f) + (g + h))</span><br></pre></td></tr></table></figure><p>我们可以用任何顺序进行计算，甚至直接将每个任务分派给不同节点开始并行计算！</p><h3 id="List的折叠"><a href="#List的折叠" class="headerlink" title="List的折叠"></a>List的折叠</h3><p>仔细观察，你会发现当我们对一个<code>List</code>进行<code>fold</code>操作（aka <code>reduce</code> in JavaScript/Python）时，传给fold的操作，恰好是monoid的<code>op</code>和<code>zero</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foldLeft(<span class="number">0</span>)((x, y) =&gt; x + y) == </span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foldLeft(intAddtion.zero)(intAddtion.op)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> intAddtionMonoid: <span class="type">Monoid</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以可以写一个更加通用的函数，接收一个<code>List[A]</code>和一个<code>Monoid[A]</code>，并用这个monoid去折叠：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concatenate</span></span>[<span class="type">A</span>](as: <span class="type">List</span>[<span class="type">A</span>], m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">  as.foldLeft(m.zero)(m.op)</span><br></pre></td></tr></table></figure><p>甚至可以将<code>List[A]</code> map 成<code>list[B]</code>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">List</span>[<span class="type">A</span>], m: <span class="type">Monoid</span>[<span class="type">B</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">B</span> = </span><br><span class="line">  as.foldLeft(m.zero)(b =&gt; a =&gt; m.op(b, f(a)))</span><br></pre></td></tr></table></figure><h3 id="通用折叠"><a href="#通用折叠" class="headerlink" title="通用折叠"></a>通用折叠</h3><p>事实上，对于所有的可折叠数据结构，我们都可以忽略其具体结构，直接用monoid进行折叠。</p><p>比如，我们有一个存放了<code>Int</code>的可折叠结构，计算其总和：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ints.foldRight(intAddtionMonoid.zero)(intAddtionMonoid.op)</span><br></pre></td></tr></table></figure><p>我们并不关心，这个ints，究竟是<code>List</code>还是<code>Array</code>还是<code>Vector</code>，甚至可能是<code>Tree</code>或者<code>Stream</code>！</p><p>对于这些结构，我们给它起个名字，叫做<code>Foldable</code>，我们可以抽象成这样：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Foldable</span>[<span class="type">F</span>[_]] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(z: <span class="type">B</span>)(f: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(z: <span class="type">B</span>)(f: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foldMap</span></span>[<span class="type">A</span>, <span class="type">B</span>](as: <span class="type">F</span>[<span class="type">A</span>])(f: <span class="type">A</span> =&gt; <span class="type">B</span>)(mb: <span class="type">Monoid</span>[<span class="type">B</span>]): <span class="type">B</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">concatenate</span></span>[<span class="type">A</span>](as: <span class="type">F</span>[<span class="type">A</span>])(m: <span class="type">Monoid</span>[<span class="type">A</span>]): <span class="type">A</span> = </span><br><span class="line">    foldLeft(as)(m.zero)(m.op)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：<code>F[_]</code>代表一个F是一个类型构造器，接收一个类型参数。比如，<code>F[A]</code>可以具象成<code>List[Int]</code>，<code>Stream[String]</code>等等。</p><h3 id="Monoid的组合"><a href="#Monoid的组合" class="headerlink" title="Monoid的组合"></a>Monoid的组合</h3><p><strong>若类型<code>A</code>和<code>B</code>是monoid，那么tuple类型<code>(A, B)</code>同样也是monoid。</strong></p><p>我们只需要将A和B的<code>op</code>和<code>zero</code>组合成<code>tuple</code>就可以了。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// am: Monoid[A], bm: Monoid[B]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tupleMonoid</span></span>[<span class="type">A</span>, <span class="type">B</span>]: <span class="type">Monoid</span>[(<span class="type">A</span>, <span class="type">B</span>)] = <span class="keyword">new</span> <span class="type">Monoid</span>[(<span class="type">A</span>, <span class="type">B</span>)] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">op</span></span>(t1: (<span class="type">A</span>, <span class="type">B</span>), t2: (<span class="type">A</span>, <span class="type">B</span>)): (<span class="type">A</span>, <span class="type">B</span>) = (t1, t2) <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ((a1, b1), (a2, b2)) =&gt; (am.op(a1, a2), bm.op(b1, b2))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> zero: (<span class="type">A</span>, <span class="type">B</span>) = (am.zero, bm.zero)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闲谈"><a href="#闲谈" class="headerlink" title="闲谈"></a>闲谈</h2><ul><li>Monoid可以算作FP中最简单的纯代数（purely algebraic）结构。</li><li>这种抽象的意义在于——和编程中的任何抽象一样——<strong>消除重复代码</strong>：抽出通用的结构，表达为抽象的类型和接口，从而消除重复。另外，这种抽象还能降低沟通成本。</li><li>Monoid中文名称叫做幺半群，十分拗口，所以全文都没有出现这个名字。</li><li>Monoid名称出自于抽象代数，我们也完全可以叫作AssociateWithIdentity，对我们编程也是毫无影响的。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><p><a href="https://deque.blog/2017/09/13/monoids-what-they-are-why-they-are-useful-and-what-they-teach-us-about-software/" target="_blank" rel="noopener">What monoids teach us about software</a></p></li><li><p><a href="http://comonad.com/reader/wp-content/uploads/2009/07/AllAboutMonoids.pdf" target="_blank" rel="noopener">All about monoids</a></p></li><li><p><a href="https://bartoszmilewski.com/2014/12/05/categories-great-and-small/" target="_blank" rel="noopener">Categories Great and Small</a></p></li><li><p>Chapter 10 of <a href="https://www.manning.com/books/functional-programming-in-scala" target="_blank" rel="noopener">Functional Programming in Scala</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Monoid-是什么？&quot;&gt;&lt;a href=&quot;#Monoid-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Monoid 是什么？&quot;&gt;&lt;/a&gt;Monoid 是什么？&lt;/h2&gt;&lt;p&gt;我们先看两组例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// string concatenation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;concat(&lt;span class=&quot;string&quot;&gt;&quot;foo&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;bar&quot;&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;foobar&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;concat(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;latte&quot;&lt;/span&gt;) == concat(&lt;span class=&quot;string&quot;&gt;&quot;latte&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;latte&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;concat(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, concat(&lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;)) == concat(concat(&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;b&quot;&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;) == &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// integer addition&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;) == (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以发现，这两组操作其实有着相同的模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一个“零值”，记作&lt;code&gt;zero&lt;/code&gt;，例子中分别是&lt;code&gt;空串&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有一个二元操作符，记作&lt;code&gt;op&lt;/code&gt;，例子中分别是&lt;code&gt;concat&lt;/code&gt;和&lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;op&lt;/code&gt;满足结合律（associativity），即&lt;code&gt;op(x, op(y, z)) == op(op(x, y), z)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;零值是单位元，即&lt;code&gt;op(zero, x) == op(x, zero) == x&lt;/code&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Functional Programming" scheme="http://duanyifu.com/tags/Functional-Programming/"/>
    
      <category term="Scala" scheme="http://duanyifu.com/tags/Scala/"/>
    
      <category term="Monoid" scheme="http://duanyifu.com/tags/Monoid/"/>
    
  </entry>
  
  <entry>
    <title>Yet Another a Introduction to Y Combinator in Scheme</title>
    <link href="http://duanyifu.com/2017/05/02/ycombinator-in-scheme/"/>
    <id>http://duanyifu.com/2017/05/02/ycombinator-in-scheme/</id>
    <published>2017-05-02T07:31:56.000Z</published>
    <updated>2019-07-28T14:08:22.075Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Lambda演算中，函数是没有名字的（都是匿名函数），那么如果函数没有名字，也就无法在函数体内显式地调用自身，也就无法定义递归函数，Y combinator就是用来解决这个问题的。<br>这篇文章想抛开那些数学概念，用程序语言（Scheme）的形式来讲解我们是如何推导出Y combinator的。  </p><p>运行环境：<br>IDE：<a href="https://racket-lang.org/" target="_blank" rel="noopener">DrRacket</a><br><a id="more"></a></p><h3 id="什么是递归函数？"><a href="#什么是递归函数？" class="headerlink" title="什么是递归函数？"></a>什么是递归函数？</h3><p>我们以递归函数<code>length</code>为例，<code>length</code>函数接受一个list，返回list的元素数目。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><br><strong>若你熟悉Scheme函数定义，可以跳过本小结后面部分。</strong></p><p><code>(define length</code>，<code>define</code>表达式将一个表达式（表达式即可能是函数也可能是值，在Scheme中并不区分这两点）绑定至一个名字，形式如同<code>(define name func)</code>，之后便可以使用<code>name</code>调用<code>func</code>这个函数。在本定义中，<code>func</code>是后面整个用括号包围的<code>lambda</code>表达式，也就是2-4行。<br><code>(lambda args body)</code>，<code>lambda</code>表达式定义了一个匿名函数，表达式中第二个元素是参数列表，第三个元素是函数体。也就是说，这个匿名函数接受一个参数<code>lst</code>，然后对函数体进行求值。<br><code>(if condition then else)</code>,<code>if</code>表达式，若<code>condition</code>为真，则求值<code>then</code>，若<code>condition</code>为假，则求值<code>else</code>。<br><code>null?</code>接受一个list，判断是否为空。<br><code>add1</code>接受一个值，将其加1后返回，定义如下：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> add1</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">+</span></span> <span class="number">1</span> n)))</span><br><span class="line"></span><br><span class="line">&gt; (add1 3)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><br><code>rest</code>返回<code>lst</code>去掉第一个元素的剩余部分，其实就是<code>(define rest cdr)</code>。<br>也就是说，<code>length</code>函数接受一个list，若list为空，则返回<code>0</code>，若list非空，则求去掉第一个元素的list长度，并将其加一。求值过程如下：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">length</span></span> `(<span class="number">1</span> <span class="number">2</span>)) <span class="comment">; `(1 2) is a list has two elements</span></span><br><span class="line">(<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> `(<span class="number">2</span>))) <span class="comment">; `(2) is (rest `(1 2))</span></span><br><span class="line">(<span class="name">add1</span> (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> `()))) <span class="comment">; `() is empty list</span></span><br><span class="line">(<span class="name">add1</span> (<span class="name">add1</span> <span class="number">0</span>))</span><br><span class="line">(<span class="name">add1</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><h3 id="假如length没有名字？"><a href="#假如length没有名字？" class="headerlink" title="假如length没有名字？"></a>假如length没有名字？</h3><p>如果我们去掉<code>define</code>，拿出其中的函数定义，是这样。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))) <span class="comment">; length is undefined</span></span><br></pre></td></tr></table></figure><br><strong>WAIT！！</strong>既然现在没有了<code>length</code>,显然我们也无法在函数体内调用<code>length</code>了。<br>那么我们应该把<code>length</code>换成什么呢？<br>我也不知道。<br>那么我们先试一试换成别的吧。<br>假设我们现在有一个函数<code>id</code>,这个函数什么都不做，只接受一个参数并将其返回，定义如下。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> id</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x) x))</span><br><span class="line"></span><br><span class="line">&gt; (id 1)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><br>那么，我们把<code>id</code>丢进<code>length</code>定义里面试试：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><br>看上去是个奇怪的函数，这个函数能工作吗？<br>我们可以试一试。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ((lambda (lst)</span><br><span class="line">   (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">       <span class="number">0</span></span><br><span class="line">       (add1 (id (rest lst)))))</span><br><span class="line"> `())</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><br>我们喂给这个奇怪的函数一个空list，它居然能返回正确的值！<br>具体原因，请读者先自己思考一下（笑<br>。<br>。<br>。<br>很简单，因为<code>(null? lst)</code>为真，所以<code>if</code>表达式直接返回了<code>0</code>，压根没有对<code>(add1 (id (rest lst)))</code>进行求值。<br>那么我们如果喂<code>(apple)</code>呢，显然这个奇怪的函数并不能返回正确的长度，因为<code>(id (rest lst))</code>无法给出“去掉第一个值的list的长度”。<br>总结一下，这个奇怪的函数：</p><ul><li>若list长度为0，可以正常工作</li><li>若list长度大于0，无法工作</li></ul><p>那么，我们将这个函数叫做<code>length0</code>,代表它对长度为0及0以下（并不存在）的list可以正常工作。</p><h3 id="length1-length2-and-…"><a href="#length1-length2-and-…" class="headerlink" title="length1, length2, and …"></a>length1, length2, and …</h3><p>好了，我们现在有一个<code>length0</code>，可以求出空表的长度。<br>那么下面这个函数有什么作用呢？<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">length0</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><br>由于<code>(length0 (rest lst))</code>是可以正确计算的，所以上面这个函数，可以计算长度小于等于1的list的长度。<br>你可能会问，但是我们没有<code>length0</code>这个名字呀？<br>没关系，我们将<code>length0</code>代换成上一小结的匿名函数形式，如下：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                   <span class="number">0</span></span><br><span class="line">                   (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br><span class="line">             (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><br>那么这个函数，我们就可以把它叫作<code>length1</code>了，因为它可以正确求出长度小于等于1的list的长度！<br>那么，<code>length2</code>就再来一次啦，把<code>length1</code>丢进那个定义，也不需要显式使用<code>length2</code>啦！<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length2</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">      <span class="number">0</span></span><br><span class="line">      (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">               (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                   <span class="number">0</span></span><br><span class="line">                   (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">                            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                                <span class="number">0</span></span><br><span class="line">                                (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br><span class="line">                          (<span class="name">rest</span> lst)))))</span><br><span class="line">             (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><br>试一试<code>length2</code>！<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ((lambda (lst)</span><br><span class="line">   (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">       <span class="number">0</span></span><br><span class="line">       (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">                (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                    <span class="number">0</span></span><br><span class="line">                    (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">                             (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">                                 <span class="number">0</span></span><br><span class="line">                                 (<span class="name">add1</span> (<span class="name">id</span> (<span class="name">rest</span> lst)))))</span><br><span class="line">                           (<span class="name">rest</span> lst)))))</span><br><span class="line">              (rest lst)))))</span><br><span class="line"> `(two apple))</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><br>真棒！现在能解决长度小于等于2的list了！<br>依此类推，我们能定义出<code>length3</code>、<code>length4</code>、<code>length5</code>,甚至<code>length100</code>、<code>length1000</code>、<code>length10000</code>了！<br>那么如果我们能写出<code>length∞</code>，不就得到了我们的原始<code>length</code>函数了吗，因为<code>length</code>是可以处理任意长度的list的函数！<br>但是，我们没办法写出<code>length∞</code>，因为无穷行代码哪里也放不下啊！（笑</p><h3 id="试着进行抽象"><a href="#试着进行抽象" class="headerlink" title="试着进行抽象"></a>试着进行抽象</h3><p>试着观察<code>length0</code> <code>length1</code> <code>length2</code>，我们会发现，这三个函数都遵循相同的形式，只有<code>last-length</code>这个地方是需要改变的：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; same pattern</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))</span><br></pre></td></tr></table></figure><br>根据DRY原则，我们为什么不把相同的形式给抽象出来呢？<br>我们可以写出一个函数，接受一个参数<code>last-length</code>，然后就可以利用这个函数生成之后的<code>length[i]</code>了。<br>就像这样：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; abstract-length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><br>这个函数接受参数<code>last-length</code>,然后就会返回一个新的函数，可以比<code>last-length</code>多处理一个长度的list。<br>那么，<code>length0</code>可以表示为：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">id</span>))</span><br></pre></td></tr></table></figure><br>那么同理，<code>length1</code>可以表示为：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">length0</span>))</span><br></pre></td></tr></table></figure><br>当然，我们并没有<code>length0</code>,需要将其转换为匿名形式，也就是这样：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">id</span>)))</span><br></pre></td></tr></table></figure><br>那么<code>length2</code>？<br>容易，再来一次：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length2</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> (<span class="name">id</span>))))</span><br></pre></td></tr></table></figure><br><strong>WAIT!!!!!!</strong>这难道不是依然在重复增加代码吗？<br>好吧，其实我们还是有所推进，别急，慢慢来。  </p><h3 id="返回length函数的函数：make-length"><a href="#返回length函数的函数：make-length" class="headerlink" title="返回length函数的函数：make-length"></a>返回length函数的函数：make-length</h3><p>按照我们刚刚的抽象，<code>abstract-length</code>：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; abstract-length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure><br>对于这个函数，我们如果：</p><ul><li>喂给它<code>id</code>,即<code>(abstract-length id)</code>，那么它会返回<code>length0</code></li><li>喂给它<code>length[i]</code>，即<code>(abstract-length length[i])</code>，那么它会返回<code>length[i+1]</code><br>既然这个函数能够返回我们需要的<code>length[i]</code>,不妨将其称之为<code>make-length</code>函数。<br>那就可以写成函数应用的形式，就像我们对<code>last-length</code>的抽象：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> id))</span><br><span class="line"> abstract-length)</span><br></pre></td></tr></table></figure>依然运用我们的old trick，将<code>abstract-length</code>写成匿名形式：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> id))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure>好了，虽然这个形式看上去很复杂，但是它就是我们熟悉的<code>length0</code>!<br>那么，<code>length1</code>呢？<br>很简单，我们只需要将<code>length0</code>喂给我们的<code>abstract-length</code>，就会得到<code>length1</code>。也就是将<code>length0</code>中的<code>id</code>替换成<code>length0</code>：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> length0))</span><br><span class="line"> abstract-length)</span><br></pre></td></tr></table></figure>换成匿名表达：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> (<span class="name">make-length</span> id)))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure>再进一步，<code>length2</code>：<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length2</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> (<span class="name">make-length</span> (<span class="name">make-length</span> id))))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure>那，<code>length3</code>？<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length3</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> (<span class="name">make-length</span> (<span class="name">make-length</span> (<span class="name">make-length</span> id)))))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure>好了好了，就不再继续演示了。<br>那么回顾一下我们的新表示方法，好像它们之间的差别，仅仅在于对参数<code>id</code>应用了多少次<code>make-length</code>函数：</li><li><code>length0</code>: (make-length id)</li><li><code>length1</code>: (make-length (make-length id))</li><li><code>length2</code>: (make-length (make-length (make-length id)))</li><li><code>length3</code>: (make-length (make-length (make-length (make-length id))))</li></ul><p>是不是有点类似汉诺塔？</p><h3 id="快到终点了"><a href="#快到终点了" class="headerlink" title="快到终点了"></a>快到终点了</h3><p>事实上，每当我们使用<code>length</code>函数，我们并不会给它一个无限长的list。<br>那么，只要我们用一个足够大的<code>length[i]</code>，可不可行呢？按照我们上一小节的抽象，我们可以轻易地写出<code>length100</code>，甚至<code>length10000000000000000</code>。<br>问题在于，这个足够大的数，仍然可能不够大。  </p><p>那么什么时候我们会知道，这个数不够大呢？<br>显然，当我们需要用到最最最最内层的函数<code>id</code>，也就是计算<code>(id (rest lst))</code>的时候，就代表，这个数不够大了。</p><p><strong>注意：</strong>我们喂给<code>length2</code>一个长度小于等于2的list时，<code>id</code>的函数应用是没有求值的。</p><p>那么，如果每当我们需要对<code>id</code>的函数应用求值的时候，我们再对其应用一次<code>make-length</code>，不就可以避免对<code>id</code>的函数应用求值了吗？</p><p>那么，如果我们从不对<code>id</code>的函数应用求值，也就是说，<code>id</code>根本没什么用，我们可以把<strong>任意函数</strong>传递给最内层的<code>make-length</code>。</p><p>那么，为何不试一试把<code>make-length</code>作为最内层的参数传给<code>make-length</code>呢。<br>那么，<code>length0</code>:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (last-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">last-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><br>回过头来看，其实<code>last-length</code>也是接受一个参数<code>length[i]</code>，然后返回新的函数<code>length[i+1]</code>。  </p><p>那不是和<code>make-length</code>一样了？<br>是这样。<br>那我们将<code>last-length</code>改名为<code>make-length</code>也可以吗？<br>可以。只要保持函数参数和函数体内的名字一致即可。<br>那我们改名吧：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length0</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name">make-length</span> (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure></p><p>进一步，依照刚刚所说，我们只需要将<code>length1</code>中最内层的函数应用添加一层<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name">make-length</span> id) (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure><br>等等？为什么<code>id</code>又出现了？<br>因为我们只能处理长度小于等于1的list。<br>如何解决此困境？<br>再次将<code>make-length</code>传递给自身，这样每当我们需要更长的<code>length[i]</code>的时候，就会自动将函数的处理能力+1。<br>就像这样：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length1</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name">make-length</span> make-length) (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure></p><p>这个函数的工作机理是，它展开的层数总是和喂给它的<code>list</code>长度一样多。因为一旦层数不够长，他就会将<code>make-length</code>应用于自身，增加多一次的处理。</p><p>试一试<code>length1</code>能否工作:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; (((lambda (make-length)</span><br><span class="line">    (make-length make-length))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (add1 ((make-length make-length) (rest lst)))))))</span><br><span class="line"> `(apple))</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"> &gt; (((lambda (make-length)</span><br><span class="line">    (make-length make-length))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">          (add1 ((make-length make-length) (rest lst)))))))</span><br><span class="line"> `(two apple))</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>很好，我们得到了一个能工作的<code>length1</code>，事实上，这已经不再是<code>length1</code>了，因为它能处理长度为2的list！甚至更长的！<br>这就和我们最初的<code>length</code>一样了！  </p><p>（如果你不明白这里的<code>length1</code>为何能工作，可以试着再读一读这两个小节，或者手动推演一下这个lambda式子）</p><h3 id="不止应用于length"><a href="#不止应用于length" class="headerlink" title="不止应用于length"></a>不止应用于length</h3><p>对比一下我们的显式递归<code>length</code>和<code>newlength</code>:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name">make-length</span> make-length) (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure></p><p>这两个定义在形式上还是有差别，因为前者定义中的<code>(length (rest lst))</code>，在后者定义中变成了<code>((make-length make-length) (rest lst))</code>。  </p><p>为了使它们表现的一致，我们将<code>(make-length make-length)</code>抽象出来就好了，然后作为参数传进去，而且我们将参数取名为<code>length</code>！</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">    <span class="comment">;;;;;;;</span></span><br><span class="line">     (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">       (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">           <span class="number">0</span></span><br><span class="line">           (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    <span class="comment">;;;;;;;</span></span><br><span class="line">   (<span class="name">make-length</span> make-length))))</span><br></pre></td></tr></table></figure><p>好了，看上去大功告成，可以把两个定义在形式上相同的地方抽象出来，这样就可以用在别的递归函数定义中了。  </p><p>WAIT！还没完，我们试着用一用<code>newlength</code>，试着对<code>(apple)</code>求值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; (((lambda (make-length)</span><br><span class="line">    (make-length make-length))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">     (make-length make-length))))</span><br><span class="line"> `(apple))</span><br></pre></td></tr></table></figure><p>我们需要将这个表达式的值求出来，然后应用到<code>(apple)</code>上<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> <span class="comment">; A-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    (<span class="name">make-length</span> make-length)))</span><br><span class="line"> <span class="comment">; A-end</span></span><br><span class="line"> )</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p><p>首先我们需要将<code>(lambda (make-length) (make-length make-length))</code>应用于后面那个式子(记作A)上，得到<code>(A A)</code>，即：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> <span class="comment">; B-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    (<span class="name">make-length</span> make-length)))</span><br><span class="line"> <span class="comment">; B-end</span></span><br><span class="line"> <span class="comment">; C-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    (<span class="name">make-length</span> make-length)))</span><br><span class="line"> <span class="comment">; C-end</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p><p>然后继续求值，将B应用于C，也就是将B的参数<code>make-length</code>用C进行代换，得到：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(</span><br><span class="line"> <span class="comment">; D-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> <span class="comment">; D-end</span></span><br><span class="line"> <span class="comment">; E-start</span></span><br><span class="line"> ((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">     (<span class="name">make-length</span> make-length)))</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">    ((<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">       (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">         (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">             <span class="number">0</span></span><br><span class="line">             (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">     (<span class="name">make-length</span> make-length))))</span><br><span class="line"> <span class="comment">; E-end</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>现在我们得到了形如<code>(D E)</code>的式子，然后我们继续求值，你会注意到，E的形状和刚刚我们得到的<code>(A A)</code>形状是一样的，所以我们会在这里一直循环下去。  </p><p>这就很奇怪了，我们在把<code>(make-length make-length)</code>抽象出来之前函数都是好的呀？  </p><p>回想一下，<code>make-length</code>的作用是生成一个新的<code>length[i+1]</code>函数，然后将其应用于一个list。<br>但是我们把<code>(make-length make-length)</code>抽象出来之后，我们无法得到这个<code>length[i+1]</code>函数，因为Scheme是应用序求值策略，<code>make-length</code>反复对自身进行应用。<br>因此，我们要想一个办法，先让<code>make-length</code>的应用停一停，等到需要它对自身进行应用的时候，再继续。<br>这个方法并不复杂，就是将<code>(make-length make-length)</code>包裹在一个<code>lambda</code>表达式之中，即<code>(lambda (x) ((make-length make-length) x))</code>。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> ((<span class="name"><span class="builtin-name">lambda</span></span> (x) ((<span class="name">make-length</span> make-length) x))</span><br><span class="line">                (<span class="name">rest</span> lst)))))))</span><br></pre></td></tr></table></figure></p><p>然后我们再把它抽象出来。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; new newlength</span></span><br><span class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (<span class="name">make-length</span> make-length))</span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">   (</span><br><span class="line">    <span class="comment">;;;;;;</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">      (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">        (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">            (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line">    <span class="comment">;;;;;;</span></span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (x) ((<span class="name">make-length</span> make-length) x)))))</span><br><span class="line"></span><br><span class="line"><span class="comment">; length</span></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> length</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br></pre></td></tr></table></figure></p><p>这样，我们就得能正确使用的<code>newlength</code>了，就能继续我们的抽象工作了。  </p><p>对比一下<code>newlength</code>和原始<code>length</code>，使用“;;;;;;”分隔开的部分，完全就是原始<code>length</code>的定义，除了将原始<code>length</code>定义中的<code>define</code>替换成<code>lambda</code>。而且这部分，和<code>make-length</code>完全无关！</p><p>那么，我们将这部分抽象出来，使其变成一个函数应用。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> <span class="comment">; Y-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (a-func)</span><br><span class="line">   ((<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">      (<span class="name">make-length</span> make-length))</span><br><span class="line">    (<span class="name"><span class="builtin-name">lambda</span></span> (make-length)</span><br><span class="line">      (<span class="name">a-func</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                ((<span class="name">make-length</span> make-length) x))))))</span><br><span class="line"> <span class="comment">; Y-end</span></span><br><span class="line"> <span class="comment">; F-start</span></span><br><span class="line"> (<span class="name"><span class="builtin-name">lambda</span></span> (length)</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (lst)</span><br><span class="line">     (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">null?</span></span> lst)</span><br><span class="line">         <span class="number">0</span></span><br><span class="line">         (<span class="name">add1</span> (<span class="name"><span class="builtin-name">length</span></span> (<span class="name">rest</span> lst))))))</span><br><span class="line"> <span class="comment">; F-end</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>现在我们有了两部分，Y和F：</p><ul><li>Y部分是一个函数，它接受一个和原始<code>length</code>具有相同形式的函数，然后返回一个递归函数<code>length</code>；</li><li>F部分，就是和原始<code>length</code>形式相同的匿名函数啦。</li></ul><p>那么这个Y部分，就是我们的Y combinator！一般被称作应用序Y combinator。<br>化简一下：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; applicative-order Y combinator</span></span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (func)</span><br><span class="line">  ((<span class="name"><span class="builtin-name">lambda</span></span> (f)</span><br><span class="line">     (<span class="name">f</span> f))</span><br><span class="line">   (<span class="name"><span class="builtin-name">lambda</span></span> (f)</span><br><span class="line">     (<span class="name">func</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">             ((<span class="name">f</span> f) x))))))</span><br></pre></td></tr></table></figure><br>有了Y combinator，我们就能从匿名函数中定义递归函数了！</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>你能写出一个简单的阶乘函数<code>factorial</code>，然后用Y combinator将其变成匿名递归函数吗？</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992" target="_blank" rel="noopener"><em>The Little Schemer</em></a></li><li><a href="https://en.wikipedia.org/wiki/Fixed-point_combinator" target="_blank" rel="noopener">Fixed-point combinator - Wikipidia</a></li><li><a href="https://mitpress.mit.edu/sicp/full-text/sicp/book/node85.html" target="_blank" rel="noopener">Normal Order and Applicative Order - <em>SICP</em></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Lambda演算中，函数是没有名字的（都是匿名函数），那么如果函数没有名字，也就无法在函数体内显式地调用自身，也就无法定义递归函数，Y combinator就是用来解决这个问题的。&lt;br&gt;这篇文章想抛开那些数学概念，用程序语言（Scheme）的形式来讲解我们是如何推导出Y combinator的。  &lt;/p&gt;
&lt;p&gt;运行环境：&lt;br&gt;IDE：&lt;a href=&quot;https://racket-lang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DrRacket&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://duanyifu.com/categories/Programming/"/>
    
    
      <category term="Scheme" scheme="http://duanyifu.com/tags/Scheme/"/>
    
      <category term="Y combinator" scheme="http://duanyifu.com/tags/Y-combinator/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter10 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/09/13/PIHex10/"/>
    <id>http://duanyifu.com/2016/09/13/PIHex10/</id>
    <published>2016-09-13T13:11:45.000Z</published>
    <updated>2016-09-13T19:49:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><p>第九章的习题暂时跳过了，先更第十章。<br>开学了，事情多了起来，还要找工作，加把劲最近把这本书刷完吧！:P</p><p>其实从第8章开始，这本书对于monad就讲的太少，过几天这本书要出第二版，希望能在这方面改进改进。。。<br>我下单了一本《Haskell趣学指南》，打算结合起来看，然后再补上跳过的习题。</p><hr><h4 id="定义函数-mult-Nat-gt-Nat-gt-Nat"><a href="#定义函数-mult-Nat-gt-Nat-gt-Nat" class="headerlink" title="定义函数 mult :: Nat -&gt; Nat -&gt; Nat"></a>定义函数 mult :: Nat -&gt; Nat -&gt; Nat</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Zero</span> | <span class="type">Succ</span> <span class="type">Nat</span></span></span><br><span class="line"><span class="title">nat2int</span> :: <span class="type">Nat</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">nat2int</span> <span class="type">Zero</span> = <span class="number">0</span></span><br><span class="line"><span class="title">nat2int</span> (<span class="type">Succ</span> n) = <span class="number">1</span> + nat2int n</span><br><span class="line"></span><br><span class="line"><span class="title">int2nat</span> :: <span class="type">Int</span> -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">int2nat</span> <span class="number">0</span> = <span class="type">Zero</span></span><br><span class="line"><span class="title">int2nat</span> n = <span class="type">Succ</span> (int2nat (n - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">add</span> <span class="type">Zero</span> n = n</span><br><span class="line"><span class="title">add</span> (<span class="type">Succ</span> m) n = <span class="type">Succ</span> (add m n)</span><br><span class="line"></span><br><span class="line"><span class="title">mult</span> :: <span class="type">Nat</span> -&gt; <span class="type">Nat</span> -&gt; <span class="type">Nat</span></span><br><span class="line"><span class="title">mult</span> <span class="type">Zero</span> _ = <span class="type">Zero</span></span><br><span class="line"><span class="title">mult</span> (<span class="type">Succ</span> m) n = add (mult m n) n</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 2) (int2nat 3))</span></span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 0) (int2nat 3))</span></span><br><span class="line"><span class="comment">-- 0</span></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 1) (int2nat 3))</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- *Main&gt; nat2int(mult (int2nat 10) (int2nat 13))</span></span><br><span class="line"><span class="comment">-- 130</span></span><br></pre></td></tr></table></figure><h4 id="重新定义occurs-Int-gt-Tree-gt-Bool"><a href="#重新定义occurs-Int-gt-Tree-gt-Bool" class="headerlink" title="重新定义occurs :: Int -&gt; Tree -&gt; Bool"></a>重新定义<code>occurs :: Int -&gt; Tree -&gt; Bool</code></h4><p>需要使用标准库<code>data Ordering = LT | EQ | GT</code>, 以及<br><code>compare :: Ord =&gt; a -&gt; a -&gt; Ordering</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> = <span class="type">Leaf</span> <span class="type">Int</span> | <span class="type">Node</span> <span class="type">Tree</span> <span class="type">Int</span> <span class="type">Tree</span></span></span><br><span class="line"><span class="title">tr</span> :: <span class="type">Tree</span></span><br><span class="line"><span class="title">tr</span> = <span class="type">Node</span> (<span class="type">Node</span> (<span class="type">Leaf</span> <span class="number">1</span>) <span class="number">3</span> (<span class="type">Leaf</span> <span class="number">4</span>)) <span class="number">5</span> (<span class="type">Node</span> (<span class="type">Leaf</span> <span class="number">6</span>) <span class="number">7</span> (<span class="type">Leaf</span> <span class="number">9</span>))</span><br><span class="line"><span class="title">occurs</span> :: <span class="type">Int</span> -&gt; <span class="type">Tree</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">occurs</span> m (<span class="type">Leaf</span> n) = m == n</span><br><span class="line"><span class="title">occurs</span> m (<span class="type">Node</span> l n r) = <span class="keyword">case</span> compare m n <span class="keyword">of</span></span><br><span class="line">                            <span class="type">LT</span> -&gt; occurs m l</span><br><span class="line">                            <span class="type">EQ</span> -&gt; <span class="type">True</span></span><br><span class="line">                            <span class="type">GT</span> -&gt; occurs m r</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="判断平衡树balanced-Tree-gt-Bool"><a href="#判断平衡树balanced-Tree-gt-Bool" class="headerlink" title="判断平衡树balanced :: Tree -&gt; Bool"></a>判断平衡树<code>balanced :: Tree -&gt; Bool</code></h4><p>平衡树：左、右子树的叶子数量相差不超过一个<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree1</span> = <span class="type">Leaf1</span> <span class="type">Int</span> | <span class="type">Node1</span> <span class="type">Tree1</span> <span class="type">Tree1</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">t1</span> :: <span class="type">Tree1</span></span><br><span class="line"><span class="title">t1</span> = <span class="type">Node1</span> (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Leaf1</span> <span class="number">4</span>)) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">6</span>) (<span class="type">Leaf1</span> <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">t2</span> :: <span class="type">Tree1</span></span><br><span class="line"><span class="title">t2</span> = <span class="type">Node1</span> (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Leaf1</span> <span class="number">4</span>))) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">6</span>) (<span class="type">Leaf1</span> <span class="number">9</span>))</span><br><span class="line"></span><br><span class="line"><span class="title">t3</span> :: <span class="type">Tree1</span></span><br><span class="line"><span class="title">t3</span> = <span class="type">Node1</span> (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Node1</span> (<span class="type">Leaf1</span> <span class="number">1</span>) (<span class="type">Leaf1</span> <span class="number">4</span>))) (<span class="type">Leaf1</span> <span class="number">6</span>)</span><br><span class="line"><span class="title">leafs</span> :: <span class="type">Tree1</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">leafs</span> (<span class="type">Leaf1</span> _) = <span class="number">1</span></span><br><span class="line"><span class="title">leafs</span> (<span class="type">Node1</span> l r) = leafs l + leafs r</span><br><span class="line"></span><br><span class="line"><span class="title">balanced</span> :: <span class="type">Tree1</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">balanced</span> (<span class="type">Leaf1</span> _) = <span class="type">True</span></span><br><span class="line"><span class="title">balanced</span> (<span class="type">Node1</span> l r) = abs (leafs l - leafs r) &lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; balanced t1</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; balanced t2</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; balanced t3</span></span><br><span class="line"><span class="comment">-- False</span></span><br></pre></td></tr></table></figure></p><h4 id="根据list生成一个平衡树"><a href="#根据list生成一个平衡树" class="headerlink" title="根据list生成一个平衡树"></a>根据list生成一个平衡树</h4><p>思路也蛮简单，把list分成两半，然后递归就成了。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">balance</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Tree1</span></span><br><span class="line"><span class="title">balance</span> xs</span><br><span class="line">    | null xs = error <span class="string">""</span></span><br><span class="line">    | length xs == <span class="number">1</span> = <span class="type">Leaf1</span> (head xs)</span><br><span class="line">    | otherwise = <span class="type">Node1</span> (balance x) (balance y)</span><br><span class="line">                    <span class="keyword">where</span> n = length xs `div` <span class="number">2</span></span><br><span class="line">                          x = take n xs</span><br><span class="line">                          y = drop n xs</span><br><span class="line"></span><br><span class="line"><span class="title">flatten</span> :: <span class="type">Tree1</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">flatten</span> (<span class="type">Leaf1</span> n) = [n]</span><br><span class="line"><span class="title">flatten</span> (<span class="type">Node1</span> l r) = flatten l ++ flatten r</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; flatten (balance [])</span></span><br><span class="line"><span class="comment">-- *** Exception:</span></span><br><span class="line"><span class="comment">-- CallStack (from HasCallStack):</span></span><br><span class="line"><span class="comment">--   error, called at ch10ex.hs:71:24 in main:Main</span></span><br><span class="line"><span class="comment">-- *Main&gt; flatten (balance [1])</span></span><br><span class="line"><span class="comment">-- [1]</span></span><br><span class="line"><span class="comment">-- *Main&gt; flatten (balance [1,2,3,4])</span></span><br><span class="line"><span class="comment">-- [1,2,3,4]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改Tautology-checker使之支持-disjunction-和-lt-gt-equivalence-运算符"><a href="#修改Tautology-checker使之支持-disjunction-和-lt-gt-equivalence-运算符" class="headerlink" title="修改Tautology checker使之支持\/(disjunction)和&lt;=&gt;(equivalence)运算符"></a>修改Tautology checker使之支持<code>\/</code>(disjunction)和<code>&lt;=&gt;</code>(equivalence)运算符</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Assoc</span> k v = [(<span class="title">k</span>, <span class="title">v</span>)]</span></span><br><span class="line"><span class="title">find</span> :: <span class="type">Eq</span> k =&gt; k -&gt; <span class="type">Assoc</span> k v -&gt; v</span><br><span class="line"><span class="title">find</span> k t = head [v | (k', v) &lt;- t, k == k']</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Prop</span> = <span class="type">Const</span> <span class="type">Bool</span></span></span><br><span class="line">          | <span class="type">Var</span> <span class="type">Char</span></span><br><span class="line">          | <span class="type">Not</span> <span class="type">Prop</span></span><br><span class="line">          | <span class="type">And</span> <span class="type">Prop</span> <span class="type">Prop</span></span><br><span class="line">          | <span class="type">Disj</span> <span class="type">Prop</span> <span class="type">Prop</span> <span class="comment">-- disjunction</span></span><br><span class="line">          | <span class="type">Equi</span> <span class="type">Prop</span> <span class="type">Prop</span> <span class="comment">-- equivalence</span></span><br><span class="line">          | <span class="type">Imply</span> <span class="type">Prop</span> <span class="type">Prop</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Subst</span> = <span class="type">Assoc</span> <span class="type">Char</span> <span class="type">Bool</span></span></span><br><span class="line"><span class="comment">-- [('A', True), ('B', False)]</span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Subst</span> -&gt; <span class="type">Prop</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">eval</span> _ (<span class="type">Const</span> b) = b</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Var</span> x) = find x s</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Not</span> p) = not (eval s p)</span><br><span class="line"><span class="title">eval</span> s (<span class="type">And</span> p q) = eval s p &amp;&amp; eval s q</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Disj</span> p q) = eval s p || eval s q</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Equi</span> p q) = eval s p == eval s q</span><br><span class="line"><span class="title">eval</span> s (<span class="type">Imply</span> p q) = eval s p &lt;= eval s q</span><br><span class="line"></span><br><span class="line"><span class="title">vars</span> :: <span class="type">Prop</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">vars</span> (<span class="type">Const</span> _) = []</span><br><span class="line"><span class="title">vars</span> (<span class="type">Var</span> x) = [x]</span><br><span class="line"><span class="title">vars</span> (<span class="type">Not</span> p) = vars p</span><br><span class="line"><span class="title">vars</span> (<span class="type">And</span> p q) = vars p ++ vars q</span><br><span class="line"><span class="title">vars</span> (<span class="type">Disj</span> p q) = vars p ++ vars q</span><br><span class="line"><span class="title">vars</span> (<span class="type">Equi</span> p q) = vars p ++ vars q</span><br><span class="line"><span class="title">vars</span> (<span class="type">Imply</span> p q) = vars p ++ vars q</span><br><span class="line"></span><br><span class="line"><span class="title">bools</span> :: <span class="type">Int</span> -&gt; [[<span class="type">Bool</span>]]</span><br><span class="line"><span class="title">bools</span> <span class="number">0</span> = [[]]</span><br><span class="line"><span class="title">bools</span> n = map (<span class="type">False</span>:) bss ++ map (<span class="type">True</span>:) bss</span><br><span class="line">                    <span class="keyword">where</span> bss = bools (n - <span class="number">1</span>)</span><br><span class="line"><span class="title">rmdups</span> :: <span class="type">Eq</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">rmdups</span> [] = []</span><br><span class="line"><span class="title">rmdups</span> (x : xs) = x : rmdups (filter (/= x) xs)</span><br><span class="line"></span><br><span class="line"><span class="title">substs</span> :: <span class="type">Prop</span> -&gt; [<span class="type">Subst</span>]</span><br><span class="line"><span class="title">substs</span> p = map (zip us) (bools (length us))</span><br><span class="line">            <span class="keyword">where</span> us = rmdups (vars p)</span><br><span class="line"><span class="title">isTaut</span> :: <span class="type">Prop</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isTaut</span> p = and [eval s p | s &lt;- substs p]</span><br><span class="line"></span><br><span class="line"><span class="title">p1</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p1</span> = <span class="type">Equi</span> (<span class="type">Var</span> '<span class="type">A'</span>) (<span class="type">Not</span> (<span class="type">Var</span> '<span class="type">A'</span>))</span><br><span class="line"><span class="title">p2</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p2</span> = <span class="type">Equi</span> (<span class="type">Var</span> '<span class="type">A'</span>) (<span class="type">Var</span> '<span class="type">A'</span>)</span><br><span class="line"><span class="title">p3</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p3</span> = <span class="type">Equi</span> (<span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Var</span> '<span class="type">B'</span>)) (<span class="type">Var</span> '<span class="type">A'</span>)) (<span class="type">Disj</span> (<span class="type">Var</span> '<span class="type">A'</span>) (<span class="type">Var</span> '<span class="type">B'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- p4 : (!(!(!P \/ Q) \/ P) \/ P)</span></span><br><span class="line"><span class="title">p4</span> :: <span class="type">Prop</span></span><br><span class="line"><span class="title">p4</span> = <span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Disj</span> (<span class="type">Not</span> (<span class="type">Var</span> '<span class="type">A'</span>)) (<span class="type">Var</span> '<span class="type">B'</span>))) (<span class="type">Var</span> '<span class="type">A'</span>))) (<span class="type">Var</span> '<span class="type">A'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p1</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p2</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p3</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; isTaut p4</span></span><br><span class="line"><span class="comment">-- True</span></span><br></pre></td></tr></table></figure><h4 id="扩展Abstract-machine使之支持乘法"><a href="#扩展Abstract-machine使之支持乘法" class="headerlink" title="扩展Abstract machine使之支持乘法"></a>扩展Abstract machine使之支持乘法</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 7 abstract machine</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Expr</span> = <span class="type">Val</span> <span class="type">Int</span> | <span class="type">Add</span> <span class="type">Expr</span> <span class="type">Expr</span> | <span class="type">Mul</span> <span class="type">Expr</span> <span class="type">Expr</span></span></span><br><span class="line"><span class="comment">-- value :: Expr -&gt; Int</span></span><br><span class="line"><span class="comment">-- value (Val n) = n</span></span><br><span class="line"><span class="comment">-- value (Add x y) = value x + value y</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Cont</span> = [<span class="type">Op</span>]</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Op</span> = <span class="type">EVALADD</span> <span class="type">Expr</span> | <span class="type">EVALMUL</span> <span class="type">Expr</span> | <span class="type">ADD</span> <span class="type">Int</span> | <span class="type">MUL</span> <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">Expr</span> -&gt; <span class="type">Cont</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Val</span> n) c = exec c n</span><br><span class="line"><span class="title">eval</span> (<span class="type">Add</span> x y) c = eval x (<span class="type">EVALADD</span> y : c)</span><br><span class="line"><span class="title">eval</span> (<span class="type">Mul</span> x y) c = eval x (<span class="type">EVALMUL</span> y : c)</span><br><span class="line"></span><br><span class="line"><span class="title">exec</span> :: <span class="type">Cont</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">exec</span> [] n = n</span><br><span class="line"><span class="title">exec</span> (<span class="type">EVALADD</span> y : c) n = eval y (<span class="type">ADD</span> n : c)</span><br><span class="line"><span class="title">exec</span> (<span class="type">EVALMUL</span> y : c) n = eval y (<span class="type">MUL</span> n : c)</span><br><span class="line"><span class="title">exec</span> (<span class="type">ADD</span> n : c) m = exec c (n + m)</span><br><span class="line"><span class="title">exec</span> (<span class="type">MUL</span> n : c) m = exec c (n * m)</span><br><span class="line"></span><br><span class="line"><span class="title">value</span> :: <span class="type">Expr</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">value</span> e = eval e []</span><br><span class="line"></span><br><span class="line"><span class="title">p1</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">p1</span> = <span class="type">Add</span> (<span class="type">Mul</span> (<span class="type">Val</span> <span class="number">3</span>) (<span class="type">Val</span> <span class="number">2</span>)) (<span class="type">Val</span> <span class="number">5</span>) <span class="comment">-- 3 * 2 + 5</span></span><br><span class="line"></span><br><span class="line"><span class="title">p2</span> :: <span class="type">Expr</span></span><br><span class="line"><span class="title">p2</span> = <span class="type">Add</span> (<span class="type">Mul</span> (<span class="type">Val</span> <span class="number">3</span>) (<span class="type">Add</span> (<span class="type">Val</span> <span class="number">3</span>) (<span class="type">Val</span> <span class="number">2</span>))) (<span class="type">Val</span> <span class="number">1</span>) <span class="comment">-- 3 * (3 + 2) + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; value p2</span></span><br><span class="line"><span class="comment">-- 16</span></span><br><span class="line"><span class="comment">-- *Main&gt; value p1</span></span><br><span class="line"><span class="comment">-- 11</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第九章的习题暂时跳过了，先更第十章。&lt;br&gt;开学了，事情多了起来，还要找工作，加把劲最近把这本书刷完吧！:P&lt;/p&gt;
&lt;p&gt;其实从第8章开始，这本书对于monad就讲的太少，过几天这本书要出第二版，希望能在这方面改进改进。。。&lt;br&gt;我下单了一本《Haskell趣学指南》，打算结合起来看，然后再补上跳过的习题。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;定义函数-mult-Nat-gt-Nat-gt-Nat&quot;&gt;&lt;a href=&quot;#定义函数-mult-Nat-gt-Nat-gt-Nat&quot; class=&quot;headerlink&quot; title=&quot;定义函数 mult :: Nat -&amp;gt; Nat -&amp;gt; Nat&quot;&gt;&lt;/a&gt;定义函数 mult :: Nat -&amp;gt; Nat -&amp;gt; Nat&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; | &lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;nat2int&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;nat2int&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;nat2int&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; n) = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + nat2int n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int2nat&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int2nat&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int2nat&lt;/span&gt; n = &lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; (int2nat (n - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; n = n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;add&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; m) n = &lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; (add m n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mult&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Nat&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mult&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt; _ = &lt;span class=&quot;type&quot;&gt;Zero&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mult&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Succ&lt;/span&gt; m) n = add (mult m n) n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 2) (int2nat 3))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 0) (int2nat 3))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 1) (int2nat 3))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; nat2int(mult (int2nat 10) (int2nat 13))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 130&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;重新定义occurs-Int-gt-Tree-gt-Bool&quot;&gt;&lt;a href=&quot;#重新定义occurs-Int-gt-Tree-gt-Bool&quot; class=&quot;headerlink&quot; title=&quot;重新定义occurs :: Int -&amp;gt; Tree -&amp;gt; Bool&quot;&gt;&lt;/a&gt;重新定义&lt;code&gt;occurs :: Int -&amp;gt; Tree -&amp;gt; Bool&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;需要使用标准库&lt;code&gt;data Ordering = LT | EQ | GT&lt;/code&gt;, 以及&lt;br&gt;&lt;code&gt;compare :: Ord =&amp;gt; a -&amp;gt; a -&amp;gt; Ordering&lt;/code&gt;。&lt;br&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; | &lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;tr&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;occurs&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Tree&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;occurs&lt;/span&gt; m (&lt;span class=&quot;type&quot;&gt;Leaf&lt;/span&gt; n) = m == n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;occurs&lt;/span&gt; m (&lt;span class=&quot;type&quot;&gt;Node&lt;/span&gt; l n r) = &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; compare m n &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;type&quot;&gt;LT&lt;/span&gt; -&amp;gt; occurs m l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;type&quot;&gt;EQ&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            &lt;span class=&quot;type&quot;&gt;GT&lt;/span&gt; -&amp;gt; occurs m r&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter8 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/09/08/PIHex8/"/>
    <id>http://duanyifu.com/2016/09/08/PIHex8/</id>
    <published>2016-09-08T13:24:24.000Z</published>
    <updated>2016-09-13T19:49:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><p>这章信息量简直爆炸，书上给的东西太少了，讲的又太多了。找了一堆资料看了好久才弄明白。</p><p>结合的参考资料如下：<br><a href="http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13" target="_blank" rel="noopener">Chapter8讲课视频</a><br><a href="http://www.cs.uwyo.edu/~jlc/courses/3015/parser_pearl.pdf" target="_blank" rel="noopener">Monadic Parsing in Haskell</a><br><a href="http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function" target="_blank" rel="noopener">“Programming In Haskell” error in sat function</a></p><p>按照书上的<code>Parser</code>定义，是没法使用do notation的，所以下面的习题全部用<code>&gt;&gt;=</code>完成。</p><p>完整的代码我放在<a href="https://gist.github.com/mistwave/b48c517e18436f6ac8fe350de929ee6a" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="int-Parser-Int"><a href="#int-Parser-Int" class="headerlink" title="int :: Parser Int"></a><code>int :: Parser Int</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">int</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">int</span> = natural +++</span><br><span class="line">      (symbol <span class="string">"-"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">       natural &gt;&gt;= \x -&gt;</span><br><span class="line">       return (-x))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; parse int "123da"</span></span><br><span class="line"><span class="comment">-- [(123,"da")]</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse int "sdada"</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse int "-213sdada"</span></span><br><span class="line"><span class="comment">-- [(-213,"sdada")]</span></span><br></pre></td></tr></table></figure><h4 id="comment-Parser"><a href="#comment-Parser" class="headerlink" title="comment :: Parser ()"></a><code>comment :: Parser ()</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">comment</span> :: <span class="type">Parser</span> ()</span><br><span class="line"><span class="title">comment</span> = symbol <span class="string">"--"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">          many (sat (/= '\n')) &gt;&gt;= \_ -&gt;</span><br><span class="line">          many (char '\n') &gt;&gt;= \_ -&gt;</span><br><span class="line">          return ()  <span class="comment">-- why return ()?</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse comment "foo"</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse comment "--foo"</span></span><br><span class="line"><span class="comment">-- [((),"")]</span></span><br><span class="line"><span class="comment">-- *Main&gt; parse comment "--foo\nbar"</span></span><br><span class="line"><span class="comment">-- [((),"bar")]</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="扩展arithmetic-expressions-parser"><a href="#扩展arithmetic-expressions-parser" class="headerlink" title="扩展arithmetic expressions parser"></a>扩展arithmetic expressions parser</h4><p>这里一个坑就是在于处理<code>8 / 2 / 2 / 2</code>，<code>1 - 2 - 3 - 4</code>这种情况，如果模仿<code>+</code>, <code>*</code>，的实现，很错误地容易把<code>8 / 2 / 2 / 2</code>parse成<code>(8 / 2) / (2 / 2)</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- new gramma rules:</span></span><br><span class="line"><span class="comment">-- expr   ::= term (+ expr | - expr | &lt;E&gt;)</span></span><br><span class="line"><span class="comment">-- term   ::= power (* term | / term | &lt;E&gt;)</span></span><br><span class="line"><span class="comment">-- power  ::= factor (^ power | &lt;E&gt;)</span></span><br><span class="line"><span class="comment">-- factor ::= (expr) | nat</span></span><br><span class="line"><span class="comment">-- nat    ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- !! WRONG:</span></span><br><span class="line"><span class="comment">-- (symbol "-" &gt;&gt;= \_ -&gt;</span></span><br><span class="line"><span class="comment">--  expr &gt;&gt;= \e -&gt;</span></span><br><span class="line"><span class="comment">--  return (ex - e))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (symbol "/" &gt;&gt;= \_ -&gt;</span></span><br><span class="line"><span class="comment">--  term &gt;&gt;= \t -&gt;</span></span><br><span class="line"><span class="comment">--  return (f `div` t))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">expr</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">expr</span> = term &gt;&gt;= \t -&gt;</span><br><span class="line">       (symbol <span class="string">"+"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">        expr       &gt;&gt;= \e -&gt;</span><br><span class="line">        return (t + e))</span><br><span class="line">       +++</span><br><span class="line">       (many (symbol <span class="string">"-"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">              term       &gt;&gt;= \n -&gt;</span><br><span class="line">              return n)  &gt;&gt;= \ss -&gt;</span><br><span class="line">        return (foldl (-) t ss))</span><br><span class="line">       +++</span><br><span class="line">       return t</span><br><span class="line"></span><br><span class="line"><span class="title">term</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">term</span> = power &gt;&gt;= \p -&gt;</span><br><span class="line">       (symbol <span class="string">"*"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">        term       &gt;&gt;= \t -&gt;</span><br><span class="line">        return (p * t))</span><br><span class="line">       +++</span><br><span class="line">       (many (symbol <span class="string">"/"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">              power      &gt;&gt;= \t -&gt;</span><br><span class="line">              return t)  &gt;&gt;= \ss -&gt;</span><br><span class="line">        return (foldl div p ss))</span><br><span class="line">       +++</span><br><span class="line">       return p</span><br><span class="line"></span><br><span class="line"><span class="title">power</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">power</span> = factor &gt;&gt;= \f -&gt;</span><br><span class="line">        (symbol <span class="string">"^"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">         power      &gt;&gt;= \p -&gt;</span><br><span class="line">         return (f ^ p))</span><br><span class="line">        +++ return f</span><br><span class="line"></span><br><span class="line"><span class="title">factor</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">factor</span> = (symbol <span class="string">"("</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">          expr       &gt;&gt;= \e -&gt;</span><br><span class="line">          symbol <span class="string">")"</span> &gt;&gt;= \_ -&gt;</span><br><span class="line">          return e)</span><br><span class="line">         +++ natural</span><br><span class="line"></span><br><span class="line"><span class="title">eval</span> :: <span class="type">String</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">eval</span> xs = <span class="keyword">case</span> parse expr xs <span class="keyword">of</span></span><br><span class="line">            [(n, [])] -&gt; n</span><br><span class="line">            [(_, out)] -&gt; error(<span class="string">"unused input "</span> ++ out)</span><br><span class="line">            [] -&gt; error <span class="string">"invalid input"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2^3"</span></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2*3 ^ 4"</span></span><br><span class="line"><span class="comment">-- 1296</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2 ^ 3 * 4"</span></span><br><span class="line"><span class="comment">-- 4096</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2 + 2^ 2"</span></span><br><span class="line"><span class="comment">-- 6</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "2^2^2"</span></span><br><span class="line"><span class="comment">-- 16</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "8-2-2-2"</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- *Main&gt; eval "16 /2/2/2"</span></span><br><span class="line"><span class="comment">-- 2</span></span><br></pre></td></tr></table></figure><h4 id="考虑expr-expr-nat-nat的parser"><a href="#考虑expr-expr-nat-nat的parser" class="headerlink" title="考虑expr ::= expr - nat | nat的parser"></a>考虑<code>expr ::= expr - nat | nat</code>的parser</h4><p>要注意的点在和上一题是一样的.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- expr'  ::= expr' - nat | nat</span></span><br><span class="line"><span class="comment">-- nat    ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"></span><br><span class="line"><span class="title">expr'</span> :: <span class="type">Parser</span> <span class="type">Int</span></span><br><span class="line"><span class="title">expr'</span> = natural &gt;&gt;= \n -&gt;</span><br><span class="line">        many (symbol <span class="string">"-"</span> &gt;&gt;= \_ -&gt; natural) &gt;&gt;= \ns -&gt;</span><br><span class="line">        return (foldl (-) n ns)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这章信息量简直爆炸，书上给的东西太少了，讲的又太多了。找了一堆资料看了好久才弄明白。&lt;/p&gt;
&lt;p&gt;结合的参考资料如下：&lt;br&gt;&lt;a href=&quot;http://channel9.msdn.com/Series/C9-Lectures-Erik-Meijer-Functional-Programming-Fundamentals/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chapter8讲课视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cs.uwyo.edu/~jlc/courses/3015/parser_pearl.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Monadic Parsing in Haskell&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;“Programming In Haskell” error in sat function&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照书上的&lt;code&gt;Parser&lt;/code&gt;定义，是没法使用do notation的，所以下面的习题全部用&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;完成。&lt;/p&gt;
&lt;p&gt;完整的代码我放在&lt;a href=&quot;https://gist.github.com/mistwave/b48c517e18436f6ac8fe350de929ee6a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;int-Parser-Int&quot;&gt;&lt;a href=&quot;#int-Parser-Int&quot; class=&quot;headerlink&quot; title=&quot;int :: Parser Int&quot;&gt;&lt;/a&gt;&lt;code&gt;int :: Parser Int&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;int&lt;/span&gt; = natural +++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      (symbol &lt;span class=&quot;string&quot;&gt;&quot;-&quot;&lt;/span&gt; &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       natural &amp;gt;&amp;gt;= \x -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       return (-x))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse int &quot;123da&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [(123,&quot;da&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse int &quot;sdada&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse int &quot;-213sdada&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [(-213,&quot;sdada&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;comment-Parser&quot;&gt;&lt;a href=&quot;#comment-Parser&quot; class=&quot;headerlink&quot; title=&quot;comment :: Parser ()&quot;&gt;&lt;/a&gt;&lt;code&gt;comment :: Parser ()&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;comment&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Parser&lt;/span&gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;comment&lt;/span&gt; = symbol &lt;span class=&quot;string&quot;&gt;&quot;--&quot;&lt;/span&gt; &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          many (sat (/= &#39;\n&#39;)) &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          many (char &#39;\n&#39;) &amp;gt;&amp;gt;= \_ -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return ()  &lt;span class=&quot;comment&quot;&gt;-- why return ()?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse comment &quot;foo&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse comment &quot;--foo&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [((),&quot;&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; parse comment &quot;--foo\nbar&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [((),&quot;bar&quot;)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter7 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/31/PIHex7/"/>
    <id>http://duanyifu.com/2016/08/31/PIHex7/</id>
    <published>2016-08-31T13:14:51.000Z</published>
    <updated>2016-09-04T13:23:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="用map和filter表示-f-x-x-lt-xs-p-x"><a href="#用map和filter表示-f-x-x-lt-xs-p-x" class="headerlink" title="用map和filter表示[f x | x &lt;- xs, p x]"></a>用<code>map</code>和<code>filter</code>表示<code>[f x | x &lt;- xs, p x]</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [f x | x &lt;- xs, p x]</span></span><br><span class="line"><span class="comment">-- [f x | x &lt;- xs, p x]</span></span><br><span class="line"><span class="comment">-- = map f (filter p xs)</span></span><br></pre></td></tr></table></figure><h4 id="定义高阶函数all-any-takeWhile-dropWhile"><a href="#定义高阶函数all-any-takeWhile-dropWhile" class="headerlink" title="定义高阶函数all, any, takeWhile, dropWhile"></a>定义高阶函数<code>all</code>, <code>any</code>, <code>takeWhile</code>, <code>dropWhile</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myall</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myall</span> _ [] = <span class="type">True</span></span><br><span class="line"><span class="title">myall</span> p (x : xs) | p x == <span class="type">False</span> = <span class="type">False</span></span><br><span class="line">                 | otherwise = myall p xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myall (&gt;3) [1..3]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myall (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myall (&gt;3) [4..5]</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"></span><br><span class="line"><span class="title">myany</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myany</span> _ [] = <span class="type">False</span></span><br><span class="line"><span class="title">myany</span> p (x : xs) | p x == <span class="type">True</span> = <span class="type">True</span></span><br><span class="line">                 | otherwise = myany p xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myany (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; myany (&gt;3) [1..3]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">mytakeWhile</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mytakeWhile</span> _ [] = []</span><br><span class="line"><span class="title">mytakeWhile</span> p (x : xs) | p x == <span class="type">True</span> = x : mytakeWhile p xs</span><br><span class="line">                       | otherwise = []</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mytakeWhile (&lt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytakeWhile (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytakeWhile (&lt;3) [1,2,3,1,2]</span></span><br><span class="line"><span class="comment">-- [1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="title">mydropWhile</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mydropWhile</span> _ [] = []</span><br><span class="line"><span class="title">mydropWhile</span> p (x : xs) | p x == <span class="type">True</span> = mydropWhile p xs</span><br><span class="line">                       | otherwise = x : xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mydropWhile (&lt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- [3,4,5]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mydropWhile (&gt;3) [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="用foldr定义map-f和filter-p"><a href="#用foldr定义map-f和filter-p" class="headerlink" title="用foldr定义map f和filter p"></a>用<code>foldr</code>定义<code>map f</code>和<code>filter p</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mymap</span> f = foldr (\x xs -&gt; f x : xs) []</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mymap (*3) [1..6]</span></span><br><span class="line"><span class="comment">-- [3,6,9,12,15,18]</span></span><br><span class="line"><span class="title">myfilter</span> p = foldr (\x xs -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : xs <span class="keyword">else</span> xs) []</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用foldl定义dec2int-Int-gt-Int"><a href="#用foldl定义dec2int-Int-gt-Int" class="headerlink" title="用foldl定义dec2int :: [Int] -&gt; Int"></a>用<code>foldl</code>定义<code>dec2int :: [Int] -&gt; Int</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">dec2int</span> :: [<span class="type">Int</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">dec2int</span> = foldl (\x y -&gt; x * <span class="number">10</span> + y) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; dec2int [2,3,4,5]</span></span><br><span class="line"><span class="comment">-- 2345</span></span><br><span class="line"><span class="comment">-- *Main&gt; dec2int [2]</span></span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="comment">-- *Main&gt; dec2int []</span></span><br><span class="line"><span class="comment">-- 0</span></span><br></pre></td></tr></table></figure><h4 id="修改错误：sumsqreven-compose-sum-map-2-filter-even"><a href="#修改错误：sumsqreven-compose-sum-map-2-filter-even" class="headerlink" title="修改错误：sumsqreven = compose [sum, map (^2), filter even]"></a>修改错误：<code>sumsqreven = compose [sum, map (^2), filter even]</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compose</span> = foldr (.) id</span><br><span class="line"></span><br><span class="line"><span class="title">sumsqreven</span> xs = sum (compose [map (^<span class="number">2</span>), filter even] xs)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="curry-amp-uncurry"><a href="#curry-amp-uncurry" class="headerlink" title="curry &amp; uncurry"></a><code>curry</code> &amp; <code>uncurry</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 6</span></span><br><span class="line"></span><br><span class="line"><span class="title">mycurry</span> :: ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)</span><br><span class="line"><span class="title">mycurry</span> f = \x y -&gt; f (x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">myuncurry</span> :: (a -&gt; b -&gt; c) -&gt; ((a, b) -&gt; c)</span><br><span class="line"><span class="title">myuncurry</span> f = \(x, y) -&gt; f x y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="利用unfold定义chop8-map-f-iterate-f"><a href="#利用unfold定义chop8-map-f-iterate-f" class="headerlink" title="利用unfold定义chop8, map f, iterate f"></a>利用<code>unfold</code>定义<code>chop8</code>, <code>map f</code>, <code>iterate f</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">unfold</span> p h t x | p x = []</span><br><span class="line">               | otherwise = h x : unfold p h t (t x)</span><br><span class="line"></span><br><span class="line"><span class="title">int2bin'</span> = unfold (== <span class="number">0</span>) (`mod` <span class="number">2</span>) (`div` <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">chop8'</span> :: [<span class="type">Int</span>] -&gt; [[<span class="type">Int</span>]]</span><br><span class="line"><span class="title">chop8'</span> = unfold (== []) (take <span class="number">8</span>) (drop <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">mymap'</span> f = unfold (== []) (f.head) tail</span><br><span class="line"></span><br><span class="line"><span class="title">myiterate</span> f = unfold (\_ -&gt; <span class="type">False</span>) id f</span><br></pre></td></tr></table></figure><h4 id="给string-transmitter程序加上奇偶校验位（parity-bit）"><a href="#给string-transmitter程序加上奇偶校验位（parity-bit）" class="headerlink" title="给string transmitter程序加上奇偶校验位（parity bit）"></a>给string transmitter程序加上奇偶校验位（parity bit）</h4><p>我这里是在数据位的末端添加的，奇数个1则为1，否则为0。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- import Data.Char</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Bit</span> = <span class="type">Int</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">bin2int</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="comment">-- bin2int bits = sum [w * b | (w, b) &lt;- zip weights bits]</span></span><br><span class="line"><span class="comment">--                 where weights = iterate (*2) 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">bin2int</span> = foldr (\x y -&gt; x + <span class="number">2</span> * y) <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="title">int2bin</span> :: <span class="type">Int</span> -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">int2bin</span> <span class="number">0</span> = []</span><br><span class="line"><span class="title">int2bin</span> n = n `mod` <span class="number">2</span> : int2bin (n `div` <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">make8</span> :: [<span class="type">Bit</span>] -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">make8</span> bits = take <span class="number">8</span> (bits ++ repeat <span class="number">0</span>)</span><br><span class="line"><span class="comment">--new</span></span><br><span class="line"><span class="title">count1</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">Bit</span></span><br><span class="line"><span class="title">count1</span> = (`mod` <span class="number">2</span>) . sum</span><br><span class="line"><span class="comment">--new</span></span><br><span class="line"><span class="title">addparitybits</span> :: [<span class="type">Bit</span>] -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">addparitybits</span> bits = bits ++ [count1 bits]</span><br><span class="line"><span class="comment">--modifyed</span></span><br><span class="line"><span class="title">encode</span> :: <span class="type">String</span> -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">encode</span> = concat.map (addparitybits.make8.int2bin.ord)</span><br><span class="line"></span><br><span class="line"><span class="title">chop9</span> :: [<span class="type">Bit</span>] -&gt; [[<span class="type">Bit</span>]]</span><br><span class="line"><span class="title">chop9</span> [] = []</span><br><span class="line"><span class="title">chop9</span> bits = take <span class="number">9</span> bits : chop9 (drop <span class="number">9</span> bits)</span><br><span class="line"></span><br><span class="line"><span class="comment">--new</span></span><br><span class="line"><span class="title">isvalid</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isvalid</span> bits = (count1 (take <span class="number">8</span> bits)) == (last bits)</span><br><span class="line"></span><br><span class="line"><span class="title">decode</span> :: [<span class="type">Bit</span>] -&gt; <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="title">decode</span> xs | all isvalid (chop9 xs) = map (chr.bin2int.(take <span class="number">8</span>)) (chop9 xs)</span><br><span class="line">          | otherwise = error <span class="string">"Wrong parity bit!"</span></span><br><span class="line"></span><br><span class="line"><span class="title">transmit</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">transmit</span> = decode.channel.encode</span><br><span class="line"></span><br><span class="line"><span class="title">channel</span> :: [<span class="type">Bit</span>] -&gt; [<span class="type">Bit</span>]</span><br><span class="line"><span class="title">channel</span> = id</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; decode (encode "abc")</span></span><br><span class="line"><span class="comment">-- "abc"</span></span><br><span class="line"><span class="comment">-- *Main&gt; (encode "abc")</span></span><br><span class="line"><span class="comment">-- [1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0]</span></span><br><span class="line"><span class="comment">-- *Main&gt; decode [1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0,1,1,0,1] --&gt; change last bit</span></span><br><span class="line"><span class="comment">-- "*** Exception: Wrong parity bit!</span></span><br><span class="line"><span class="comment">-- CallStack (from HasCallStack):</span></span><br><span class="line"><span class="comment">--   error, called at ch7ex.hs:149:25 in main:Main</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 9</span></span><br><span class="line"><span class="title">transmit'</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">transmit'</span> = decode.tail.encode</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; transmit "abc"</span></span><br><span class="line"><span class="comment">-- "abc"</span></span><br><span class="line"><span class="comment">-- *Main&gt; transmit' "abc"</span></span><br><span class="line"><span class="comment">-- "*** Exception: Wrong parity bit!</span></span><br><span class="line"><span class="comment">-- CallStack (from HasCallStack):</span></span><br><span class="line"><span class="comment">--   error, called at ch7ex.hs:147:25 in main:Main</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;用map和filter表示-f-x-x-lt-xs-p-x&quot;&gt;&lt;a href=&quot;#用map和filter表示-f-x-x-lt-xs-p-x&quot; class=&quot;headerlink&quot; title=&quot;用map和filter表示[f x | x &amp;lt;- xs, p x]&quot;&gt;&lt;/a&gt;用&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;filter&lt;/code&gt;表示&lt;code&gt;[f x | x &amp;lt;- xs, p x]&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [f x | x &amp;lt;- xs, p x]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [f x | x &amp;lt;- xs, p x]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = map f (filter p xs)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义高阶函数all-any-takeWhile-dropWhile&quot;&gt;&lt;a href=&quot;#定义高阶函数all-any-takeWhile-dropWhile&quot; class=&quot;headerlink&quot; title=&quot;定义高阶函数all, any, takeWhile, dropWhile&quot;&gt;&lt;/a&gt;定义高阶函数&lt;code&gt;all&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;takeWhile&lt;/code&gt;, &lt;code&gt;dropWhile&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myall&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myall&lt;/span&gt; _ [] = &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myall&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 | otherwise = myall p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myall (&amp;gt;3) [1..3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myall (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myall (&amp;gt;3) [4..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myany&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myany&lt;/span&gt; _ [] = &lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myany&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 | otherwise = myany p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myany (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; myany (&amp;gt;3) [1..3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mytakeWhile&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mytakeWhile&lt;/span&gt; _ [] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mytakeWhile&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt; = x : mytakeWhile p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       | otherwise = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mytakeWhile (&amp;lt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [1,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mytakeWhile (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mytakeWhile (&amp;lt;3) [1,2,3,1,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [1,2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mydropWhile&lt;/span&gt; :: (a -&amp;gt; &lt;span class=&quot;type&quot;&gt;Bool&lt;/span&gt;) -&amp;gt; [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mydropWhile&lt;/span&gt; _ [] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mydropWhile&lt;/span&gt; p (x : xs) | p x == &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt; = mydropWhile p xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       | otherwise = x : xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mydropWhile (&amp;lt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [3,4,5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mydropWhile (&amp;gt;3) [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [1,2,3,4,5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter6 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/28/PIHex6/"/>
    <id>http://duanyifu.com/2016/08/28/PIHex6/</id>
    <published>2016-08-28T13:13:36.000Z</published>
    <updated>2016-08-28T15:50:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><p>这一章节就是在讲递归，所以下面的定义都是默认用递归定义。</p><h4 id="定义幂函数"><a href="#定义幂函数" class="headerlink" title="定义幂函数"></a>定义幂函数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mypow</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">mypow</span> _ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">mypow</span> x n = x * mypow x (n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mypow 2 3</span></span><br><span class="line"><span class="comment">-- 8</span></span><br><span class="line"><span class="comment">-- *Main&gt; mypow 3 0</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- *Main&gt; mypow 3 1</span></span><br><span class="line"><span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><h4 id="解释length-drop-init的递归求值过程"><a href="#解释length-drop-init的递归求值过程" class="headerlink" title="解释length, drop, init的递归求值过程"></a>解释<code>length</code>, <code>drop</code>, <code>init</code>的递归求值过程</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- length [1, 2, 3]</span></span><br><span class="line"><span class="comment">-- = 1 + length [2, 3]</span></span><br><span class="line"><span class="comment">-- = 1 + (1 + length [3])</span></span><br><span class="line"><span class="comment">-- = 1 + (1 + (1 + length []))</span></span><br><span class="line"><span class="comment">-- = 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- drop 3 [1..5]</span></span><br><span class="line"><span class="comment">-- = drop 2 [2..5]</span></span><br><span class="line"><span class="comment">-- = drop 1 [3..5]</span></span><br><span class="line"><span class="comment">-- = drop 0 [4, 5]</span></span><br><span class="line"><span class="comment">-- = [4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- init [1..3]</span></span><br><span class="line"><span class="comment">-- = 1 : init [2, 3]</span></span><br><span class="line"><span class="comment">-- = 1 : 2 : init [3]</span></span><br><span class="line"><span class="comment">-- = 1 : 2 : []</span></span><br><span class="line"><span class="comment">-- = [1, 2]</span></span><br></pre></td></tr></table></figure><h4 id="定义以下库函数"><a href="#定义以下库函数" class="headerlink" title="定义以下库函数"></a>定义以下库函数</h4><a id="more"></a><h5 id="and"><a href="#and" class="headerlink" title="and"></a>and</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myand</span> :: [<span class="type">Bool</span>] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myand</span> [] = <span class="type">True</span></span><br><span class="line"><span class="title">myand</span> (n : ns) | n == <span class="type">False</span> = <span class="type">False</span></span><br><span class="line">               | otherwise = myand ns</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myand [True, True]</span></span><br><span class="line"><span class="comment">-- True</span></span><br><span class="line"><span class="comment">-- *Main&gt; myand [True, False]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myand []</span></span><br><span class="line"><span class="comment">-- True</span></span><br></pre></td></tr></table></figure><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myconcat</span> :: [[a]] -&gt; [a]</span><br><span class="line"><span class="title">myconcat</span> [] = []</span><br><span class="line"><span class="title">myconcat</span> [[a]] = [a]</span><br><span class="line"><span class="title">myconcat</span> (n : ns) = n ++ myconcat ns</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myconcat []</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; myconcat [[1,2,3]]</span></span><br><span class="line"><span class="comment">-- [1,2,3]</span></span><br><span class="line"><span class="comment">-- *Main&gt; myconcat [[1,2,3],[3,4,5],[2,7]]</span></span><br><span class="line"><span class="comment">-- [1,2,3,3,4,5,2,7]</span></span><br></pre></td></tr></table></figure><h5 id="replicate"><a href="#replicate" class="headerlink" title="replicate"></a>replicate</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myreplicate</span> :: <span class="type">Int</span> -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">myreplicate</span> <span class="number">0</span> _ = []</span><br><span class="line"><span class="title">myreplicate</span> n a = a : myreplicate (n - <span class="number">1</span>) a</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 0 True</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 1 True</span></span><br><span class="line"><span class="comment">-- [True]</span></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 3 'c'</span></span><br><span class="line"><span class="comment">-- "ccc"</span></span><br><span class="line"><span class="comment">-- *Main&gt; myreplicate 3 "hs"</span></span><br><span class="line"><span class="comment">-- ["hs","hs","hs"]</span></span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title="(!!)"></a>(!!)</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mynth</span> :: [a] -&gt; <span class="type">Int</span> -&gt; a</span><br><span class="line"><span class="title">mynth</span> (x : xs) <span class="number">0</span> = x</span><br><span class="line"><span class="title">mynth</span> (x : xs) n = mynth xs (n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 其实这里如果n大于长度应该要抛出一个异常，目前还没学到，先放着</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mynth [1..3] 0</span></span><br><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="comment">-- *Main&gt; mynth [1..3] 2</span></span><br><span class="line"><span class="comment">-- 3</span></span><br></pre></td></tr></table></figure><h5 id="elem"><a href="#elem" class="headerlink" title="elem"></a>elem</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myelem</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">myelem</span> x [] = <span class="type">False</span></span><br><span class="line"><span class="title">myelem</span> x (n : ns) | x == n = <span class="type">True</span></span><br><span class="line">                  | otherwise = myelem x ns</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; myelem 0 []</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myelem 0 [1..3]</span></span><br><span class="line"><span class="comment">-- False</span></span><br><span class="line"><span class="comment">-- *Main&gt; myelem 3 [1..3]</span></span><br><span class="line"><span class="comment">-- True</span></span><br></pre></td></tr></table></figure><h4 id="定义merge函数"><a href="#定义merge函数" class="headerlink" title="定义merge函数"></a>定义<code>merge</code>函数</h4><p>merge: 将两个有序list合并成一个有序list<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">merge</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">merge</span> [] [] = []</span><br><span class="line"><span class="title">merge</span> a [] = a</span><br><span class="line"><span class="title">merge</span> [] a = a</span><br><span class="line"><span class="title">merge</span> (n:ns) (x:xs) | x &gt;= n = n : merge ns (x:xs)</span><br><span class="line">                    | x &lt; n = x : merge (n:ns) xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; merge [1,2,3,4,5] [2,3,5,6,7]</span></span><br><span class="line"><span class="comment">-- [1,2,2,3,3,4,5,5,6,7]</span></span><br><span class="line"><span class="comment">-- *Main&gt; merge [2,5,6] [1,3,4]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5,6]</span></span><br><span class="line"><span class="comment">-- *Main&gt; merge [1,3,4] []</span></span><br><span class="line"><span class="comment">-- [1,3,4]</span></span><br><span class="line"><span class="comment">-- *Main&gt; merge [] []</span></span><br><span class="line"><span class="comment">-- []</span></span><br></pre></td></tr></table></figure></p><h4 id="利用merge定义归并排序msort"><a href="#利用merge定义归并排序msort" class="headerlink" title="利用merge定义归并排序msort"></a>利用<code>merge</code>定义归并排序<code>msort</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: [a] -&gt; ([a], [a])</span><br><span class="line"><span class="title">halve</span> xs = <span class="keyword">let</span> hl = (length xs) `div` <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line">            (take hl xs, drop hl xs)</span><br><span class="line"></span><br><span class="line"><span class="title">msort</span> :: <span class="type">Ord</span> a =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">msort</span> [] = []</span><br><span class="line"><span class="title">msort</span> [a] = [a]</span><br><span class="line"><span class="title">msort</span> xs = merge (msort (fst (halve xs))) (msort (snd (halve xs)))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; msort []</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; msort [3,1,2,4]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4]</span></span><br><span class="line"><span class="comment">-- *Main&gt; msort [7,3,4,2,4,5,6,12,33,4,22,2]</span></span><br><span class="line"><span class="comment">-- [2,2,3,4,4,4,5,6,7,12,22,33]</span></span><br></pre></td></tr></table></figure><h4 id="定义sum-take-last"><a href="#定义sum-take-last" class="headerlink" title="定义sum, take, last"></a>定义<code>sum</code>, <code>take</code>, <code>last</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title">mysum</span> :: <span class="type">Num</span> a =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">mysum</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">mysum</span> (x : xs) = x + mysum xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mysum []</span></span><br><span class="line"><span class="comment">-- 0</span></span><br><span class="line"><span class="comment">-- *Main&gt; mysum [1..5]</span></span><br><span class="line"><span class="comment">-- 15</span></span><br><span class="line"><span class="comment">-- *Main&gt; mysum [3.6,7.6,5.77]</span></span><br><span class="line"><span class="comment">-- 16.97</span></span><br><span class="line"></span><br><span class="line"><span class="title">mytake</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">mytake</span> <span class="number">0</span> _ = []</span><br><span class="line"><span class="title">mytake</span> _ [] = []</span><br><span class="line"><span class="title">mytake</span> n (x : xs) = x : mytake (n - <span class="number">1</span>) xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 0 [1..5]</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 3 [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2,3]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 7 [1..5]</span></span><br><span class="line"><span class="comment">-- [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">-- *Main&gt; mytake 7 []</span></span><br><span class="line"><span class="comment">-- []</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title">mylast</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">mylast</span> [x] = x</span><br><span class="line"><span class="title">mylast</span> (x : xs) = mylast xs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- *Main&gt; mylast [1..3]</span></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="comment">-- *Main&gt; mylast [5]</span></span><br><span class="line"><span class="comment">-- 5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;这一章节就是在讲递归，所以下面的定义都是默认用递归定义。&lt;/p&gt;
&lt;h4 id=&quot;定义幂函数&quot;&gt;&lt;a href=&quot;#定义幂函数&quot; class=&quot;headerlink&quot; title=&quot;定义幂函数&quot;&gt;&lt;/a&gt;定义幂函数&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mypow&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mypow&lt;/span&gt; _ &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;mypow&lt;/span&gt; x n = x * mypow x (n&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mypow 2 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mypow 3 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- *Main&amp;gt; mypow 3 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;解释length-drop-init的递归求值过程&quot;&gt;&lt;a href=&quot;#解释length-drop-init的递归求值过程&quot; class=&quot;headerlink&quot; title=&quot;解释length, drop, init的递归求值过程&quot;&gt;&lt;/a&gt;解释&lt;code&gt;length&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt;的递归求值过程&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- length [1, 2, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 + length [2, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 + (1 + length [3])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 + (1 + (1 + length []))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- drop 3 [1..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = drop 2 [2..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = drop 1 [3..5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = drop 0 [4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = [4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- init [1..3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 : init [2, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 : 2 : init [3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = 1 : 2 : []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- = [1, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义以下库函数&quot;&gt;&lt;a href=&quot;#定义以下库函数&quot; class=&quot;headerlink&quot; title=&quot;定义以下库函数&quot;&gt;&lt;/a&gt;定义以下库函数&lt;/h4&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter5 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/27/PIHex5/"/>
    <id>http://duanyifu.com/2016/08/27/PIHex5/</id>
    <published>2016-08-27T15:13:37.000Z</published>
    <updated>2016-08-28T15:49:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="用List-Comprehension计算1到100平方和"><a href="#用List-Comprehension计算1到100平方和" class="headerlink" title="用List Comprehension计算1到100平方和"></a>用List Comprehension计算1到100平方和</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [x^<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.100</span>]]</span><br></pre></td></tr></table></figure><h4 id="定义库函数replicate"><a href="#定义库函数replicate" class="headerlink" title="定义库函数replicate"></a>定义库函数<code>replicate</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &gt; replicate 3 True</span></span><br><span class="line"><span class="comment">-- [True, True, True]</span></span><br><span class="line"></span><br><span class="line"><span class="title">myreplicate</span> :: <span class="type">Int</span> -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">myreplicate</span> n x = [x | _ &lt;- [<span class="number">1.</span>.n]]</span><br></pre></td></tr></table></figure><h4 id="定义函数pyths"><a href="#定义函数pyths" class="headerlink" title="定义函数pyths"></a>定义函数<code>pyths</code></h4><p><code>pyths n</code>返回满足<code>x^2 + y^2 == z^2</code>的三元组<code>(x, y, z)</code>，其中xyz都小于等于n<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- &gt; paths 10</span></span><br><span class="line"><span class="comment">-- [(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]</span></span><br><span class="line"></span><br><span class="line"><span class="title">pyths</span>   :: <span class="type">Int</span> -&gt; [(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)]</span><br><span class="line"><span class="title">pyths</span> n = [(x,y,z) | x &lt;- [<span class="number">1.</span>.n],</span><br><span class="line">                     y &lt;- [<span class="number">1.</span>.n],</span><br><span class="line">                     z &lt;- [<span class="number">1.</span>.n],</span><br><span class="line">                     x^<span class="number">2</span> + y^<span class="number">2</span> == z^<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><h4 id="定义完美数函数perfects"><a href="#定义完美数函数perfects" class="headerlink" title="定义完美数函数perfects"></a>定义完美数函数<code>perfects</code></h4><p>完美数的定义：一个数所有的真因子（除掉自身以外的因子）之和等于它本身。<br>例如：6 = 1 + 2 + 3</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factors</span> :: <span class="type">Int</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">factors</span> x = [n | n &lt;- [<span class="number">1.</span>.x<span class="number">-1</span>], x `mod` n == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">perfects</span> :: <span class="type">Int</span> -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">perfects</span> n = [x | x &lt;- [<span class="number">1.</span>.n], x == sum (factors x)]</span><br></pre></td></tr></table></figure><p>深入阅读：<a href="https://en.wikipedia.org/wiki/Perfect_number" target="_blank" rel="noopener">Perfect number</a></p><h4 id="改写-x-y-x-lt-1-3-y-lt-1-3"><a href="#改写-x-y-x-lt-1-3-y-lt-1-3" class="headerlink" title="改写[(x, y) | x &lt;- [1..3], y &lt;- [1..3]]"></a>改写<code>[(x, y) | x &lt;- [1..3], y &lt;- [1..3]]</code></h4><p>将两层List Comprehension嵌套起来<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">concat</span> [[(x,y)| x &lt;- [<span class="number">1.</span><span class="number">.3</span>] ]| y &lt;- [<span class="number">1.</span><span class="number">.3</span>]]</span><br></pre></td></tr></table></figure></p><h4 id="利用find函数重新定义positions函数"><a href="#利用find函数重新定义positions函数" class="headerlink" title="利用find函数重新定义positions函数"></a>利用<code>find</code>函数重新定义<code>positions</code>函数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">positions</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [a] -&gt; [<span class="type">Int</span>]</span><br><span class="line"><span class="title">positions</span> x xs = [i | (x', i) &lt;- zip xs [<span class="number">0.</span>.n], x == x']</span><br><span class="line">                    <span class="keyword">where</span> n = length xs <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="title">find</span> :: <span class="type">Eq</span> a =&gt; a -&gt; [(a, b)] -&gt; [b]</span><br><span class="line"><span class="title">find</span> k t = [v | (k', v) &lt;- t, k == k']</span><br></pre></td></tr></table></figure><h4 id="计算内积函数scalarproduct"><a href="#计算内积函数scalarproduct" class="headerlink" title="计算内积函数scalarproduct"></a>计算内积函数<code>scalarproduct</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">scalarproduct</span> :: [<span class="type">Int</span>] -&gt; [<span class="type">Int</span>] -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">scalarproduct</span> x y = sum [x * y | (x, y) &lt;- zip x y]</span><br></pre></td></tr></table></figure><h4 id="修改书上的Caesar-cipher程序，使之能处理大写字母"><a href="#修改书上的Caesar-cipher程序，使之能处理大写字母" class="headerlink" title="修改书上的Caesar cipher程序，使之能处理大写字母"></a>修改书上的Caesar cipher程序，使之能处理大写字母</h4><p>思路是：</p><ol><li>用<code>shift</code>进行移位的时候，将大写字母、小写字母分开处理；</li><li>crack计算概率的时候，把大写字母当做小写字母处理。</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let2int</span> :: <span class="type">Char</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">let2int</span> c = ord c - ord 'a'</span><br><span class="line"></span><br><span class="line"><span class="comment">-- new</span></span><br><span class="line"><span class="title">let2intup</span> :: <span class="type">Char</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">let2intup</span> c = ord c - ord '<span class="type">A'</span></span><br><span class="line"></span><br><span class="line"><span class="title">int2let</span> :: <span class="type">Int</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">int2let</span> n = chr (ord 'a' + n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- new</span></span><br><span class="line"><span class="title">int2letup</span> :: <span class="type">Int</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">int2letup</span> n = chr (ord '<span class="type">A'</span> + n)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- modified</span></span><br><span class="line"><span class="title">shift</span> :: <span class="type">Int</span> -&gt; <span class="type">Char</span> -&gt; <span class="type">Char</span></span><br><span class="line"><span class="title">shift</span> n c | isLower c = int2let ((let2int c + n) `mod` <span class="number">26</span>)</span><br><span class="line">          | isUpper c = int2letup ((let2intup c + n) `mod` <span class="number">26</span>)</span><br><span class="line">          | otherwise = c</span><br><span class="line"></span><br><span class="line"><span class="title">table</span> :: [<span class="type">Float</span>]</span><br><span class="line"><span class="title">table</span> = [<span class="number">8.2</span>, <span class="number">1.5</span>, <span class="number">2.8</span>, <span class="number">4.3</span>, <span class="number">12.7</span>, <span class="number">2.2</span>,</span><br><span class="line">         <span class="number">2.0</span>, <span class="number">6.1</span>, <span class="number">7.0</span>, <span class="number">0.2</span>, <span class="number">0.8</span>, <span class="number">4.0</span>,</span><br><span class="line">         <span class="number">2.4</span>, <span class="number">6.7</span>, <span class="number">7.5</span>, <span class="number">1.9</span>, <span class="number">0.1</span>, <span class="number">6.0</span>,</span><br><span class="line">         <span class="number">6.3</span>, <span class="number">9.1</span>, <span class="number">2.8</span>, <span class="number">1.0</span>, <span class="number">2.4</span>, <span class="number">0.2</span>,</span><br><span class="line">         <span class="number">2.0</span>, <span class="number">0.1</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">encode</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">encode</span> n xs = [shift n x | x &lt;- xs]</span><br><span class="line"></span><br><span class="line"><span class="title">percent</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">percent</span> n m = (fromIntegral n / fromIntegral m) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="title">count</span> :: <span class="type">Char</span> -&gt; <span class="type">String</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">count</span> x xs = length [x' | x' &lt;- xs, x == x']</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lowers :: String -&gt; Int</span></span><br><span class="line"><span class="comment">-- lowers xs = length [x | x &lt;- xs, isLower x]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- new</span></span><br><span class="line"><span class="title">lowerstring</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lowerstring</span> xs = [<span class="keyword">if</span> isUpper x <span class="keyword">then</span> chr (ord x + <span class="number">32</span>) <span class="keyword">else</span> x| x &lt;- xs]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- modified</span></span><br><span class="line"><span class="title">freqs</span> :: <span class="type">String</span> -&gt; [<span class="type">Float</span>]</span><br><span class="line"><span class="title">freqs</span> xs = [percent (count x (lowerstring xs)) n | x &lt;- ['a'..'z']]</span><br><span class="line">            <span class="keyword">where</span> n = length xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- chi-square</span></span><br><span class="line"><span class="title">chisqr</span> :: [<span class="type">Float</span>] -&gt; [<span class="type">Float</span>] -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">chisqr</span> os es = sum [(o - e)^<span class="number">2</span> / e | (o, e) &lt;- zip os es]</span><br><span class="line"></span><br><span class="line"><span class="title">rotate</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">rotate</span> n xs = drop n xs ++ take n xs</span><br><span class="line"></span><br><span class="line"><span class="title">crack</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">crack</span> xs = encode (-factor) xs</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        factor = head (positions (minimum chitab) chitab)</span><br><span class="line">        chitab = [chisqr (rotate n table') table | n &lt;- [<span class="number">0.</span><span class="number">.25</span>]]</span><br><span class="line">        table' = freqs xs</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :l ch5ex.hs </span><br><span class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">Main</span>             ( ch5ex.hs, interpreted )</span><br><span class="line"><span class="type">Ok</span>, modules loaded: <span class="type">Main</span>.</span><br><span class="line">*<span class="type">Main</span>&gt; encode <span class="number">3</span> <span class="string">"HasKELL iS FuN"</span></span><br><span class="line"><span class="string">"KdvNHOO lV IxQ"</span></span><br><span class="line">*<span class="type">Main</span>&gt; crack <span class="string">"KDvnhoO Lv IXQ"</span></span><br><span class="line"><span class="string">"HAskelL Is FUN"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;用List-Comprehension计算1到100平方和&quot;&gt;&lt;a href=&quot;#用List-Comprehension计算1到100平方和&quot; class=&quot;headerlink&quot; title=&quot;用List Comprehension计算1到100平方和&quot;&gt;&lt;/a&gt;用List Comprehension计算1到100平方和&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt; [x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; | x &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.100&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义库函数replicate&quot;&gt;&lt;a href=&quot;#定义库函数replicate&quot; class=&quot;headerlink&quot; title=&quot;定义库函数replicate&quot;&gt;&lt;/a&gt;定义库函数&lt;code&gt;replicate&lt;/code&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- &amp;gt; replicate 3 True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [True, True, True]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myreplicate&lt;/span&gt; :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; a -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;myreplicate&lt;/span&gt; n x = [x | _ &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;定义函数pyths&quot;&gt;&lt;a href=&quot;#定义函数pyths&quot; class=&quot;headerlink&quot; title=&quot;定义函数pyths&quot;&gt;&lt;/a&gt;定义函数&lt;code&gt;pyths&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;pyths n&lt;/code&gt;返回满足&lt;code&gt;x^2 + y^2 == z^2&lt;/code&gt;的三元组&lt;code&gt;(x, y, z)&lt;/code&gt;，其中xyz都小于等于n&lt;br&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- &amp;gt; paths 10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- [(3, 4, 5), (4, 3, 5), (6, 8, 10), (8, 6, 10)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pyths&lt;/span&gt;   :: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt; -&amp;gt; [(&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pyths&lt;/span&gt; n = [(x,y,z) | x &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     y &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     z &amp;lt;- [&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;.n],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     x^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + y^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == z^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter4 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/26/PIHex4/"/>
    <id>http://duanyifu.com/2016/08/26/PIHex4/</id>
    <published>2016-08-25T17:00:18.000Z</published>
    <updated>2016-08-28T15:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="定义-halve"><a href="#定义-halve" class="headerlink" title="定义 halve"></a>定义 halve</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">halve</span> :: [a] -&gt; ([a], [a])</span><br><span class="line"><span class="title">halve</span> a = <span class="keyword">let</span> n = (length a) `div` <span class="number">2</span> <span class="keyword">in</span> (take n a, drop n a)</span><br></pre></td></tr></table></figure><h4 id="用三种方式定义safetail"><a href="#用三种方式定义safetail" class="headerlink" title="用三种方式定义safetail"></a>用三种方式定义safetail</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- conditional expression</span></span><br><span class="line"><span class="title">safetail1</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">safetail1</span> xs = <span class="keyword">if</span> null xs <span class="keyword">then</span> xs <span class="keyword">else</span> tail xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- guarded equations</span></span><br><span class="line"><span class="title">safetail2</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">safetail2</span> xs | null xs      = xs</span><br><span class="line">             | otherwise    = tail xs</span><br><span class="line"></span><br><span class="line"><span class="comment">-- pattern matching</span></span><br><span class="line"><span class="title">safetail3</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">safetail3</span> [] = []</span><br><span class="line"><span class="title">safetail3</span> (_:xs) = xs</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="定义并运算（disjunction-operator）"><a href="#定义并运算（disjunction-operator）" class="headerlink" title="定义并运算（disjunction operator）"></a>定义并运算（disjunction operator）</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1 all pattern matching</span></span><br><span class="line"><span class="title">md1</span> :: <span class="type">Bool</span> -&gt; <span class="type">Bool</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">md1</span> <span class="type">True</span> <span class="type">True</span> = <span class="type">True</span></span><br><span class="line"><span class="title">md1</span> <span class="type">True</span> <span class="type">False</span> = <span class="type">True</span></span><br><span class="line"><span class="title">md1</span> <span class="type">False</span> <span class="type">True</span> = <span class="type">True</span></span><br><span class="line"><span class="title">md1</span> <span class="type">False</span> <span class="type">False</span> = <span class="type">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2 wildcard pattern</span></span><br><span class="line"></span><br><span class="line"><span class="title">md2</span> <span class="type">False</span> <span class="type">False</span> = <span class="type">False</span></span><br><span class="line"><span class="title">md2</span> _ _ = <span class="type">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3</span></span><br><span class="line"><span class="title">md3</span> <span class="type">False</span> b = b</span><br><span class="line"><span class="title">md3</span> <span class="type">True</span> _ = <span class="type">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4</span></span><br><span class="line"><span class="title">md4</span> a b | a == b    = a</span><br><span class="line">        | otherwise = <span class="type">True</span></span><br></pre></td></tr></table></figure><h4 id="用条件表达式（conditional-expressions）重新定义并运算"><a href="#用条件表达式（conditional-expressions）重新定义并运算" class="headerlink" title="用条件表达式（conditional expressions）重新定义并运算"></a>用条件表达式（conditional expressions）重新定义并运算</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mc1</span> a b = <span class="keyword">if</span> a == <span class="type">False</span> <span class="keyword">then</span> <span class="type">False</span> <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> b == <span class="type">True</span> <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> <span class="type">False</span></span><br></pre></td></tr></table></figure><h4 id="同上一题"><a href="#同上一题" class="headerlink" title="同上一题"></a>同上一题</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mc2</span> a b = <span class="keyword">if</span> a == <span class="type">True</span> <span class="keyword">then</span> b <span class="keyword">else</span> <span class="type">False</span></span><br></pre></td></tr></table></figure><h4 id="用lambda表达式理解函数mult-x-y-z-x-y-z"><a href="#用lambda表达式理解函数mult-x-y-z-x-y-z" class="headerlink" title="用lambda表达式理解函数mult x y z = x * y * z"></a>用lambda表达式理解函数<code>mult x y z = x * y * z</code></h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mult</span> x y z == \x -&gt; (\y -&gt; (\z -&gt; x * y * z))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;定义-halve&quot;&gt;&lt;a href=&quot;#定义-halve&quot; class=&quot;headerlink&quot; title=&quot;定义 halve&quot;&gt;&lt;/a&gt;定义 halve&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;halve&lt;/span&gt; :: [a] -&amp;gt; ([a], [a])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;halve&lt;/span&gt; a = &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; n = (length a) `div` &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; (take n a, drop n a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;用三种方式定义safetail&quot;&gt;&lt;a href=&quot;#用三种方式定义safetail&quot; class=&quot;headerlink&quot; title=&quot;用三种方式定义safetail&quot;&gt;&lt;/a&gt;用三种方式定义safetail&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- conditional expression&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail1&lt;/span&gt; :: [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail1&lt;/span&gt; xs = &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; null xs &lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt; xs &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; tail xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- guarded equations&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail2&lt;/span&gt; :: [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail2&lt;/span&gt; xs | null xs      = xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             | otherwise    = tail xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;-- pattern matching&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail3&lt;/span&gt; :: [a] -&amp;gt; [a]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail3&lt;/span&gt; [] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;safetail3&lt;/span&gt; (_:xs) = xs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter3 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/25/PIHex3/"/>
    <id>http://duanyifu.com/2016/08/25/PIHex3/</id>
    <published>2016-08-25T15:45:14.000Z</published>
    <updated>2016-08-25T17:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="写出这些表达式的type"><a href="#写出这些表达式的type" class="headerlink" title="写出这些表达式的type"></a>写出这些表达式的type</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">['a', 'b', 'c']             <span class="comment">-- :: [Char]</span></span><br><span class="line">('a', 'b', 'c')             <span class="comment">-- :: (Char, Char, Char)</span></span><br><span class="line">[(<span class="type">False</span>, '<span class="type">O'</span>), (<span class="type">True</span>, '<span class="number">1</span>')] <span class="comment">-- :: [(Bool, Char)]</span></span><br><span class="line">([<span class="type">False</span>, <span class="type">True</span>], ['<span class="number">0</span>', '<span class="number">1</span>']) <span class="comment">-- :: ([Bool], [Char])</span></span><br><span class="line">[tail, init, reverse]       <span class="comment">-- :: [[a] -&gt; [a]]</span></span><br></pre></td></tr></table></figure><h4 id="写出这些函数的type"><a href="#写出这些函数的type" class="headerlink" title="写出这些函数的type"></a>写出这些函数的type</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">second</span> xs       = head (tail xs)    <span class="comment">-- [a] -&gt; a</span></span><br><span class="line"><span class="title">swap</span> (x, y)     = (y, x)            <span class="comment">-- (a, b) -&gt; (b, a)</span></span><br><span class="line"><span class="title">pair</span> x y        = (x, y)            <span class="comment">-- a -&gt; b -&gt; (a, b)</span></span><br><span class="line"><span class="title">double</span> x        = x * <span class="number">2</span>             <span class="comment">-- Num a =&gt; a -&gt; a</span></span><br><span class="line"><span class="title">palindrome</span> xs   = reverse xs == xs  <span class="comment">-- Eq a =&gt; a -&gt; Bool</span></span><br><span class="line"><span class="title">twice</span> f x       = f (f x)           <span class="comment">-- (a -&gt; a) -&gt; a -&gt; a</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="在Hugs中验证前两题"><a href="#在Hugs中验证前两题" class="headerlink" title="在Hugs中验证前两题"></a>在Hugs中验证前两题</h4><p>第二题中，有几个函数用<code>:t</code>查看的type是用<code>t</code> <code>t1</code>表示的，和<code>a</code> <code>b</code>是一个意思。</p><h4 id="为什么“将所有的函数类型都定义为Eq-class的实例（instance）”是不可行的？"><a href="#为什么“将所有的函数类型都定义为Eq-class的实例（instance）”是不可行的？" class="headerlink" title="为什么“将所有的函数类型都定义为Eq class的实例（instance）”是不可行的？"></a>为什么“将所有的函数类型都定义为<code>Eq class</code>的实例（instance）”是不可行的？</h4><p>题目中给出的两个函数相等的定义是这样：</p><ol><li>type相同</li><li>对于任意的输入，都拥有相同的输出</li></ol><p>显然，编译器不可能对两个函数测试所有的参数来判断它们是否相等。因为可能的参数是有无穷多个的。</p><p>深入阅读: <a href="http://stackoverflow.com/questions/10956419/why-isnt-every-type-part-of-eq-in-haskell" target="_blank" rel="noopener">Why isn’t every type part of Eq in Haskell?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写出这些表达式的type&quot;&gt;&lt;a href=&quot;#写出这些表达式的type&quot; class=&quot;headerlink&quot; title=&quot;写出这些表达式的type&quot;&gt;&lt;/a&gt;写出这些表达式的type&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]             &lt;span class=&quot;comment&quot;&gt;-- :: [Char]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)             &lt;span class=&quot;comment&quot;&gt;-- :: (Char, Char, Char)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[(&lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;, &#39;&lt;span class=&quot;type&quot;&gt;O&#39;&lt;/span&gt;), (&lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;, &#39;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&#39;)] &lt;span class=&quot;comment&quot;&gt;-- :: [(Bool, Char)]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;([&lt;span class=&quot;type&quot;&gt;False&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;True&lt;/span&gt;], [&#39;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&#39;, &#39;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&#39;]) &lt;span class=&quot;comment&quot;&gt;-- :: ([Bool], [Char])&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tail, init, reverse]       &lt;span class=&quot;comment&quot;&gt;-- :: [[a] -&amp;gt; [a]]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;写出这些函数的type&quot;&gt;&lt;a href=&quot;#写出这些函数的type&quot; class=&quot;headerlink&quot; title=&quot;写出这些函数的type&quot;&gt;&lt;/a&gt;写出这些函数的type&lt;/h4&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;second&lt;/span&gt; xs       = head (tail xs)    &lt;span class=&quot;comment&quot;&gt;-- [a] -&amp;gt; a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt; (x, y)     = (y, x)            &lt;span class=&quot;comment&quot;&gt;-- (a, b) -&amp;gt; (b, a)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;pair&lt;/span&gt; x y        = (x, y)            &lt;span class=&quot;comment&quot;&gt;-- a -&amp;gt; b -&amp;gt; (a, b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;double&lt;/span&gt; x        = x * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;             &lt;span class=&quot;comment&quot;&gt;-- Num a =&amp;gt; a -&amp;gt; a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;palindrome&lt;/span&gt; xs   = reverse xs == xs  &lt;span class=&quot;comment&quot;&gt;-- Eq a =&amp;gt; a -&amp;gt; Bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;twice&lt;/span&gt; f x       = f (f x)           &lt;span class=&quot;comment&quot;&gt;-- (a -&amp;gt; a) -&amp;gt; a -&amp;gt; a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>用Sublime Text写Haskell</title>
    <link href="http://duanyifu.com/2016/08/24/write-haskell-with-sublime/"/>
    <id>http://duanyifu.com/2016/08/24/write-haskell-with-sublime/</id>
    <published>2016-08-23T18:09:20.000Z</published>
    <updated>2016-08-23T20:00:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><ul><li><a href="https://www.haskell.org/downloads" target="_blank" rel="noopener">Haskell</a> (我选择的是Haskell Platform 8.0.1)</li><li><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text</a></li><li><a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">Package Control: The Sublime Text package manager</a></li></ul><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><h4 id="SublimeHaskell"><a href="#SublimeHaskell" class="headerlink" title="SublimeHaskell"></a>SublimeHaskell</h4><p>在Package Control中安装SublimeHaskell。<br>插件安装完成后，重启Sublime报错，提示需要安装hsdev cabal package。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SublimeHaskell: hsdev executable couldn&apos;t be found!</span><br><span class="line">It&apos;s used in most features of SublimeHaskell</span><br><span class="line">Check if it&apos;s installed and in PATH</span><br><span class="line">If it&apos;s not installed, run &apos;cabal install hsdev&apos; to install hsdev</span><br><span class="line">You may also want to adjust &apos;add_to_PATH&apos; setting</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>用cabal安装之：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install hsdev</span><br></pre></td></tr></table></figure></p><p>然后是cabal运行过程中报错，提示缺少happy cabal package。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install hsdev</span><br><span class="line">Resolving dependencies...</span><br><span class="line">Configuring haskell-src-exts-1.17.1...</span><br><span class="line">Failed to install haskell-src-exts-1.17.1</span><br><span class="line">Build log ( /Users/mist/.cabal/logs/haskell-src-exts-1.17.1.log ):</span><br><span class="line">cabal: Entering directory &apos;/var/folders/4f/s20y12v152dgfl1rqbs3ztfc0000gn/T/cabal-tmp-245/haskell-src-exts-1.17.1&apos;</span><br><span class="line">Configuring haskell-src-exts-1.17.1...</span><br><span class="line">cabal.real: The program &apos;happy&apos; version &gt;=1.19 is required but it could not be</span><br><span class="line">found.</span><br><span class="line">cabal: Leaving directory &apos;/var/folders/4f/s20y12v152dgfl1rqbs3ztfc0000gn/T/cabal-tmp-245/haskell-src-exts-1.17.1&apos;</span><br><span class="line">cabal: Error: some packages failed to install:</span><br><span class="line">haskell-src-exts-1.17.1 failed during the configure step. The exception was:</span><br><span class="line">ExitFailure 1</span><br><span class="line">hlint-1.9.35 depends on haskell-src-exts-1.17.1 which failed to install.</span><br><span class="line">hsdev-0.2.0.0 depends on haskell-src-exts-1.17.1 which failed to install.</span><br></pre></td></tr></table></figure></p><p>遂先装happy，再来装hsdev。<br>(PS: 这个hsdev包安装过程中的各种build超超超慢)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cabal install happy</span><br><span class="line">$ cabal install hsdev  </span><br></pre></td></tr></table></figure><p>等了好久终于装好了，结果打开Sublime依然报错，还需要手动配置SublimeHaskell。<br>菜单栏选<code>Preferences -&gt; Package Settings -&gt; SublimeHaskell -&gt; Settings - User</code>进行配置，文件内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"add_to_PATH"</span>:</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"/Users/mist/Library/Haskell/bin"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"enable_ghc_mod"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"enable_hdevtools"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>注意：文件中的路径应当修改为你自己的路径，可以用<code>cat ~/.cabal/where-is-my-stuff.txt</code>查看。</strong></p><p>再次重启sublime，这次没有报错。</p><h4 id="SublimeREPL"><a href="#SublimeREPL" class="headerlink" title="SublimeREPL"></a>SublimeREPL</h4><p>在Package Control中安装SublimeREPL。<br>这个插件可以直接新建一个tab用来跑GHCi，配合<code>View -&gt; Layout -&gt; Coloum: 2</code>使用，方便开发与调试。</p><h4 id="stylish-haskell"><a href="#stylish-haskell" class="headerlink" title="stylish-haskell"></a>stylish-haskell</h4><p>有待研究。</p><h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><h4 id="自带Build-System可以使用"><a href="#自带Build-System可以使用" class="headerlink" title="自带Build System可以使用"></a>自带Build System可以使用</h4><p><code>Tools -&gt; Build System -&gt; Automatic 或 Haskell</code><br>直接运行当前文件。<br><img src="http://ocdmsdl3m.bkt.clouddn.com/sublime_haskell_1.png" alt="sublime build system"></p><h4 id="SublimeHaskell常用命令"><a href="#SublimeHaskell常用命令" class="headerlink" title="SublimeHaskell常用命令"></a>SublimeHaskell常用命令</h4><p>显示声明位置：<code>f12</code><br>详细声明文档：<code>ctrl+k ctrl+i</code><br>显示类型：<code>ctrl+k ctrl+h ctrl+t</code><br>插入类型：<code>ctrl+k ctrl+i ctrl+i</code><br>当然，也可以用<code>command+shift+p</code>调用这些命令。</p><h4 id="SublimeREPL-1"><a href="#SublimeREPL-1" class="headerlink" title="SublimeREPL"></a>SublimeREPL</h4><p>不用额外配置，通过<code>Tools -&gt; SublimeREPL -&gt; Haskell</code>可以直接打开GHCi。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>生命不息，折腾不止，终于可以愉快地敲haskell啦~<br>主要的坑都在cabal上，cabal这个包管理比起 pip npm 啥的实在太弱了，连uninstall都没有！(敲<code>cabal uninstall</code>会告诉你以后会加上这个功能的。。。)</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/SublimeHaskell/SublimeHaskell" target="_blank" rel="noopener">SublimeHaskell GitHub repo</a></li><li><a href="http://tonylawrence.com/2014/01/01/configuring-your-haskell-environment/" target="_blank" rel="noopener">Configuring your Haskell environment</a></li><li><a href="http://umairsaeed.com/blog/2015/05/02/sublime-text-and-haskell/" target="_blank" rel="noopener">Sublime Text &amp; Haskell</a></li><li><a href="https://github.com/jaspervdj/stylish-haskell" target="_blank" rel="noopener">stylish-haskell GitHub repo</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基础准备&quot;&gt;&lt;a href=&quot;#基础准备&quot; class=&quot;headerlink&quot; title=&quot;基础准备&quot;&gt;&lt;/a&gt;基础准备&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.haskell.org/downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Haskell&lt;/a&gt; (我选择的是Haskell Platform 8.0.1)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sublimetext.com/3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sublime Text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://packagecontrol.io/installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Package Control: The Sublime Text package manager&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装插件&quot;&gt;&lt;a href=&quot;#安装插件&quot; class=&quot;headerlink&quot; title=&quot;安装插件&quot;&gt;&lt;/a&gt;安装插件&lt;/h3&gt;&lt;h4 id=&quot;SublimeHaskell&quot;&gt;&lt;a href=&quot;#SublimeHaskell&quot; class=&quot;headerlink&quot; title=&quot;SublimeHaskell&quot;&gt;&lt;/a&gt;SublimeHaskell&lt;/h4&gt;&lt;p&gt;在Package Control中安装SublimeHaskell。&lt;br&gt;插件安装完成后，重启Sublime报错，提示需要安装hsdev cabal package。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SublimeHaskell: hsdev executable couldn&amp;apos;t be found!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;It&amp;apos;s used in most features of SublimeHaskell&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Check if it&amp;apos;s installed and in PATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;If it&amp;apos;s not installed, run &amp;apos;cabal install hsdev&amp;apos; to install hsdev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You may also want to adjust &amp;apos;add_to_PATH&amp;apos; setting&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Sublime" scheme="http://duanyifu.com/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter2 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/23/PIHex2/"/>
    <id>http://duanyifu.com/2016/08/23/PIHex2/</id>
    <published>2016-08-23T07:13:53.000Z</published>
    <updated>2016-08-28T15:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="给算数表达式加上括号"><a href="#给算数表达式加上括号" class="headerlink" title="给算数表达式加上括号"></a>给算数表达式加上括号</h4><p>按照运算符优先级就可以，略过。</p><h4 id="修改代码，使之正确"><a href="#修改代码，使之正确" class="headerlink" title="修改代码，使之正确"></a>修改代码，使之正确</h4><p>将<code>length xs</code>用括号括起来即可。</p><h4 id="尝试定义last"><a href="#尝试定义last" class="headerlink" title="尝试定义last"></a>尝试定义<code>last</code></h4><p><code>last</code>: 返回非空list的最后一个元素<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mylast</span> a = a !! ((length a) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h4 id="尝试定义init"><a href="#尝试定义init" class="headerlink" title="尝试定义init"></a>尝试定义<code>init</code></h4><p><code>init</code>: 删除非空list的最后一个元素，并返回list<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myinit1</span> a = take ((length a) - <span class="number">1</span>) a</span><br><span class="line"></span><br><span class="line"><span class="title">myinit2</span> a = <span class="keyword">let</span> n = length a <span class="keyword">in</span> reverse (tail (reverse a))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; targe
      
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
  <entry>
    <title>hexo deploy 命令卡住的奇怪问题</title>
    <link href="http://duanyifu.com/2016/08/23/hexo-deploy-problem/"/>
    <id>http://duanyifu.com/2016/08/23/hexo-deploy-problem/</id>
    <published>2016-08-22T18:25:10.000Z</published>
    <updated>2016-08-22T18:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>用<code>hexo d</code>命令部署的时候总是会卡住很久，反复尝试了几次后，每次都是control+C告终。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▶ hexo d</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br><span class="line">^CINFO  Bye!</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>hexo d -debug</code>查看日志发现信息一直在循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">▶ hexo deploy -debug</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 620 ms</span><br><span class="line">INFO  0 files generated in 518 ms</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 468 ms</span><br><span class="line">INFO  0 files generated in 363 ms</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 342 ms</span><br><span class="line">...</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 274 ms</span><br><span class="line">INFO  0 files generated in 381 ms</span><br><span class="line">INFO  Start processing</span><br><span class="line">^CINFO  Bye!</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>首先检查_config.yml文件，看看deployment相关配置写对了没</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:mistwave/mistwave.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>对照官方文档后，发现配置并没有错，推测是ssh的问题。<br>将repo改成https地址后，问题依旧存在。</p><p>找了一些类似问题的资料后，尝试了删除<code>.deploy_git</code>，更新git版本后，问题依然没有解决。</p><p>但是在删除<code>.deploy_git</code>后，发现总是在gitlog后面卡住，推测是<code>git push</code>的问题，尝试让git走代理，问题解决，令人哭笑不得。</p><p>git配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br></pre></td></tr></table></figure><br>设置的意思是让http/https协议走代理，即Shadowsocks的本地代理。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ol><li><a href="https://github.com/hexojs/hexo/issues/1478" target="_blank" rel="noopener">hexo repo上一个类似issues</a></li><li><a href="http://www.wuliaole.com/post/the_lag_problem_for_hexo_deploying_on_github/" target="_blank" rel="noopener">hexo在github部署卡住的奇怪问题</a></li><li><a href="http://droidyue.com/blog/2016/04/04/set-shadowsocks-proxy-for-terminal/index.html" target="_blank" rel="noopener">为终端设置Shadowsocks代理</a></li><li><a href="http://blog.fazero.cc/2015/07/11/%E7%94%A8shadowsocks%E5%8A%A0%E9%80%9Fgit-clone/" target="_blank" rel="noopener">用shadowsocks加速git clone</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;用&lt;code&gt;hexo d&lt;/code&gt;命令部署的时候总是会卡住很久，反复尝试了几次后，每次都是control+C告终。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;▶ hexo d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO  Deploying: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO  Clearing .deploy_git folder...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INFO  Copying files from public folder...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nothing to commit, working directory clean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^CINFO  Bye!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="疑难杂症" scheme="http://duanyifu.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="hexo" scheme="http://duanyifu.com/tags/hexo/"/>
    
      <category term="git" scheme="http://duanyifu.com/tags/git/"/>
    
      <category term="shadowsocks" scheme="http://duanyifu.com/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Programming in Haskell Chapter1 Exercises Solutions</title>
    <link href="http://duanyifu.com/2016/08/22/PIHex1/"/>
    <id>http://duanyifu.com/2016/08/22/PIHex1/</id>
    <published>2016-08-22T15:47:22.000Z</published>
    <updated>2016-08-28T15:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Programming in Haskell</em>是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在<a href="http://www.cs.nott.ac.uk/~pszgmh/book.html" target="_blank" rel="noopener">这里</a>。</p><hr><h4 id="给出double-double-2-的另外一种可能解释。"><a href="#给出double-double-2-的另外一种可能解释。" class="headerlink" title="给出double (double 2)的另外一种可能解释。"></a>给出<code>double (double 2)</code>的另外一种可能解释。</h4><p>书上给的例子是应用序和正则序（从左向右），可以将正则序（从右向左）当作答案。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">double</span> (double <span class="number">2</span>)</span><br><span class="line">= double <span class="number">2</span> + double <span class="number">2</span></span><br><span class="line">= double <span class="number">2</span> + (<span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">= double <span class="number">2</span> + <span class="number">4</span></span><br><span class="line">= (<span class="number">2</span> + <span class="number">2</span>) + <span class="number">4</span></span><br><span class="line">= <span class="number">4</span> + <span class="number">4</span></span><br><span class="line">= <span class="number">8</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="解释sum-x-的求值过程。"><a href="#解释sum-x-的求值过程。" class="headerlink" title="解释sum [x]的求值过程。"></a>解释<code>sum [x]</code>的求值过程。</h4><p>sum的定义：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum</span> (x:xs) = x + sum xs</span><br></pre></td></tr></table></figure></p><p>sum [x] 求值过程：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> [x]</span><br><span class="line">= x + sum []</span><br><span class="line">= x + <span class="number">0</span></span><br><span class="line">= x</span><br></pre></td></tr></table></figure></p><h4 id="定义product。"><a href="#定义product。" class="headerlink" title="定义product。"></a>定义<code>product</code>。</h4><p>仿照sum的定义，将product定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> []     = <span class="number">1</span></span><br><span class="line"><span class="title">product</span> (x:xs) = x * sum xs</span><br></pre></td></tr></table></figure></p><p>product [2, 3, 4]求值过程：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">product</span> [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * product [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * product [<span class="number">4</span>]</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * product []</span><br><span class="line">= <span class="number">2</span> * <span class="number">3</span> * <span class="number">4</span> * <span class="number">1</span></span><br><span class="line">= <span class="number">24</span></span><br></pre></td></tr></table></figure></p><h4 id="将qsort改成输出倒序的。"><a href="#将qsort改成输出倒序的。" class="headerlink" title="将qsort改成输出倒序的。"></a>将<code>qsort</code>改成输出倒序的。</h4><p>将课本中的例子larger和smaller交换即可。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- qsort.hs</span></span><br><span class="line"><span class="title">qsort</span> [] = []</span><br><span class="line"><span class="title">qsort</span> (x:xs) = qsort larger ++ [x] ++ qsort smaller</span><br><span class="line">               <span class="keyword">where</span></span><br><span class="line">                larger = [a | a &lt;- xs, a &gt; x]</span><br><span class="line">                smaller = [b | b &lt;- xs, b &lt;= x]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--- *Main&gt; qsort [3,5,1,4,2]</span></span><br><span class="line"><span class="comment">--- [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure></p><h4 id="将qsort定义中的-lt-换成-lt-会如何。"><a href="#将qsort定义中的-lt-换成-lt-会如何。" class="headerlink" title="将qsort定义中的&lt;=换成&lt;会如何。"></a>将<code>qsort</code>定义中的<code>&lt;=</code>换成<code>&lt;</code>会如何。</h4><p>若将<code>&lt;=</code>换成<code>&lt;</code>，则与<code>x</code>相等的元素将会丢失。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; qsort [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">this</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Programming in Haskell&lt;/em&gt;是一本入门Haskell的好书，介绍页面以及配套的slides, vedios, codes都在&lt;a href=&quot;http://www.cs.nott.ac.uk/~pszgmh/book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;给出double-double-2-的另外一种可能解释。&quot;&gt;&lt;a href=&quot;#给出double-double-2-的另外一种可能解释。&quot; class=&quot;headerlink&quot; title=&quot;给出double (double 2)的另外一种可能解释。&quot;&gt;&lt;/a&gt;给出&lt;code&gt;double (double 2)&lt;/code&gt;的另外一种可能解释。&lt;/h4&gt;&lt;p&gt;书上给的例子是应用序和正则序（从左向右），可以将正则序（从右向左）当作答案。&lt;br&gt;&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;double&lt;/span&gt; (double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= double &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= (&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Haskell" scheme="http://duanyifu.com/categories/Haskell/"/>
    
    
      <category term="Haskell" scheme="http://duanyifu.com/tags/Haskell/"/>
    
      <category term="Programming in Haskell" scheme="http://duanyifu.com/tags/Programming-in-Haskell/"/>
    
  </entry>
  
</feed>
